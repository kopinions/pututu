{"title":"影子寄存器是什么","date":"2022-09-27T00:00:00.000Z","date_formatted":{"ll":"2022年9月27日","L":"2022/09/27","MM-DD":"09-27"},"link":"2022/09/27/shadow_register","tags":["ic"],"categories":["ic"],"updated":"2022-09-27T00:00:00.000Z","content":"<html><head></head><body><div id=\"content\">\n<p>\n影子寄存器时 ARM 的设计中引入的一个概念。在 X86, Power PC 处理器设计中都没有这个概念。我们知道 ARM 处理器中总共有 16 个通用寄存器，这 16 个通用寄存器在指令系统中\n需要有 4 bit 来进行编码寻址。但是不同模式下，同样的 4 bit 可能会指向到不同的 “物理寄存器”，这些不同的物理寄存器，我们称之为 \"影子寄存器\"。不同通用寄存器（寄存器编号），存在的影子寄存器的编号\n也不同，有的没有，有的有 1 个，有的甚至有 5 个。影子寄存器是真正存在的寄存器，只是因为正常模式下，看不到也访问不到这些寄存器，所以影子由此而来。\n</p>\n\n<div id=\"outline-container-org4c686af\" class=\"outline-2\">\n<h2 id=\"org4c686af\">缩写</h2>\n<div class=\"outline-text-2\" id=\"text-org4c686af\">\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col class=\"org-left\">\n\n<col class=\"org-left\">\n\n<col class=\"org-left\">\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">缩写</th>\n<th scope=\"col\" class=\"org-left\">全称</th>\n<th scope=\"col\" class=\"org-left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-left\">CPSR</td>\n<td class=\"org-left\">Current Program Status Register</td>\n<td class=\"org-left\">&nbsp;</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">SPSR</td>\n<td class=\"org-left\">Saved Program Status Register</td>\n<td class=\"org-left\">SPSR 在异常的时候，用来保存CPSR 中的内容，用来在异常处理完毕后跳转回来，每种异常模式都有自己的 SPSR</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">LR</td>\n<td class=\"org-left\">Link Register</td>\n<td class=\"org-left\">存放子程序的返回地址</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">SP</td>\n<td class=\"org-left\">Stack Pointer</td>\n<td class=\"org-left\">栈指针</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">PC</td>\n<td class=\"org-left\">Program Counter</td>\n<td class=\"org-left\">&nbsp;</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">STMDB</td>\n<td class=\"org-left\">STore Multiple Decrement Before</td>\n<td class=\"org-left\">将多个寄存器的内容放在内存中，其中其中指令中的寄存器制定的是内存的基址。</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">LDMIA</td>\n<td class=\"org-left\">LoaD Multiple Increment After</td>\n<td class=\"org-left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n\n<div id=\"outline-container-org556f67a\" class=\"outline-2\">\n<h2 id=\"org556f67a\">设计考虑</h2>\n<div class=\"outline-text-2\" id=\"text-org556f67a\">\n</div>\n<div id=\"outline-container-org853b218\" class=\"outline-3\">\n<h3 id=\"org853b218\">设计紧凑</h3>\n<div class=\"outline-text-3\" id=\"text-org853b218\">\n<p>\nARM 是一个非常紧凑的设计，引入影子寄存器就是这种理念的充分体现。通过引入影子寄存器，可以以一个非常小的代价来使用更多的寄存器数量。\n</p>\n</div>\n<ul class=\"org-ul\">\n<li><a id=\"org7da15d1\"></a>两种方案实现对比（粗略的）<br>\n<div class=\"outline-text-5\" id=\"text-org7da15d1\">\n<ol class=\"org-ol\">\n<li>引入更多的寄存器位数\n<ul class=\"org-ul\">\n<li>指令模块（取指，译码，访存，执行，写回） 相应的带宽，中间存储都会变大，相关处理单元也会变大（比如寄存器地址解析）</li>\n<li>指令存储也会变大</li>\n</ul></li>\n<li>引入影子寄存器\n<ul class=\"org-ul\">\n<li>只需要在相关影子寄存器通路上加上选择器，以及对应的选择信号就可以实现</li>\n</ul></li>\n</ol>\n\n<p>\n通过引入影子寄存器，指令可以重复使用相同的寄存器编码，但是在不同模式下，这些编码对应不同的物理寄存器。比如 Abort 模式下的 R13 就和用户模式下的 R13 不同。\n虽然它们编码一样，但是实际上对应的是不同的物理寄存器（可以将 CPSR 的模式域当作片选）。ARM 中实际的寄存器数目计算如下：\n</p>\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col class=\"org-left\">\n\n<col class=\"org-right\">\n\n<col class=\"org-left\">\n\n<col class=\"org-right\">\n\n<col class=\"org-left\">\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">名字</th>\n<th scope=\"col\" class=\"org-right\">数量</th>\n<th scope=\"col\" class=\"org-left\">有无影子寄存器</th>\n<th scope=\"col\" class=\"org-right\">影子寄存器数量</th>\n<th scope=\"col\" class=\"org-left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-left\">状态寄存器 CPSR</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">5</td>\n<td class=\"org-left\">五个异常模式下，每个异常模式一个，这些寄存器为 SPSR</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R0-R7</td>\n<td class=\"org-right\">8</td>\n<td class=\"org-left\">N</td>\n<td class=\"org-right\">0</td>\n<td class=\"org-left\">&nbsp;</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R8</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">FIQ 模式下的影子寄存器</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R9</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">同上</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R10</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">同上</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R11</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">同上</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R12</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">同上</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R13(sp)</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">5</td>\n<td class=\"org-left\">五个异常个模式下，每个异常一个</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R14(lr)</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">Y</td>\n<td class=\"org-right\">5</td>\n<td class=\"org-left\">同上</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">通用寄存器 R15</td>\n<td class=\"org-right\">1</td>\n<td class=\"org-left\">N</td>\n<td class=\"org-right\">0</td>\n<td class=\"org-left\">&nbsp;</td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td class=\"org-left\">&nbsp;</td>\n<td class=\"org-right\">17</td>\n<td class=\"org-left\">&nbsp;</td>\n<td class=\"org-right\">20</td>\n<td class=\"org-left\">&nbsp;</td>\n</tr>\n\n<tr>\n<td class=\"org-left\">&nbsp;</td>\n<td class=\"org-right\">37</td>\n<td class=\"org-left\">&nbsp;</td>\n<td class=\"org-right\">&nbsp;</td>\n<td class=\"org-left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n\n\n<p>\n由于影子寄存器在指令中的寄存器号编码时一样的，因此像如下的指令，在不同模式下会访问到不同的物理寄存器，他们的编号都是 R13。\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">mov R0, R13</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n这意味着：对于存在影子寄存器的情况，我们在异常模式下时没有办法访问正常的寄存器的。对于 R0-R7 这种不存在影子寄存器的情况，没有任何影响。\n</p>\n</div>\n</li>\n</ul>\n</div>\n<div id=\"outline-container-org47dcf5e\" class=\"outline-3\">\n<h3 id=\"org47dcf5e\">保存CPU状态代价小</h3>\n<div class=\"outline-text-3\" id=\"text-org47dcf5e\">\n<p>\n引入影子寄存器的另外一个好处时，在发生中断或者异常的时候，CPU 会将当前的状态保存在影子寄存器中。从 CPU 的角度来看，CPU 的状态只有俩\n</p>\n<ol class=\"org-ol\">\n<li>当前运行指令地址（PC）</li>\n<li>当前状态寄存器（CPSR）</li>\n</ol>\n\n<p>\n当出现异常或者中断时，CPU 只做如下两个操作就可以保存 CPU 状态\n</p>\n<ul class=\"org-ul\">\n<li>PC 保存在对应模式下的 R14(LR) 寄存器中，</li>\n<li>将 CPSR 存在对应模式下的 SPSR 寄存器中</li>\n</ul>\n\n<p>\n对于 R0-R12 来讲，严格意义上这个并不是 CPU 的状态，而是应用的状态，在发生中断的时候，CPU 并不关心这些寄存器。\n这些寄存器的值需要保存到内存中，这个时非常昂贵的操作。所以 ARM 提供内存访存指令，可以将一组寄存器的值保存到内存，或者将内存的值恢复到一组寄存器中。\n编译器通过相关的指令进行应用程序的状态的保存。\n</p>\n</div>\n</div>\n<div id=\"outline-container-org87107fe\" class=\"outline-3\">\n<h3 id=\"org87107fe\">中断处理流程</h3>\n<div class=\"outline-text-3\" id=\"text-org87107fe\">\n</div>\n<div id=\"outline-container-org0f69081\" class=\"outline-4\">\n<h4 id=\"org0f69081\">CPSR 寄存器</h4>\n<div class=\"outline-text-4\" id=\"text-org0f69081\">\n\n<div id=\"org4c59eb4\" class=\"figure\">\n<p><img src=\"/2022/09/27/shadow_register/cpsr.png\">\n</p>\n</div>\n\n<p>\n上表的详细解释如下：\n</p>\n<ul class=\"org-ul\">\n<li>条件位\n<ul class=\"org-ul\">\n<li>N = Negative result from ALU</li>\n<li>Z = Zero Result from ALU</li>\n<li>C = ALU operation Carried out</li>\n<li>V = ALU operation oVerflowed</li>\n</ul></li>\n<li>Q 位\n<ul class=\"org-ul\">\n<li>仅 ARM 5TE/J 架构支持</li>\n<li>指示饱和状态</li>\n</ul></li>\n<li>J 位\n<ul class=\"org-ul\">\n<li>仅 ARM 5TE/J 架构支持</li>\n<li>J = 1, 处理器处于 jazelle(direct byte code) 模式</li>\n</ul></li>\n<li>中断禁止位\n<ul class=\"org-ul\">\n<li>I = 1: 禁止 IRQ</li>\n<li>F = 1: 禁止 FIQ</li>\n</ul></li>\n<li>T Bit\n<ul class=\"org-ul\">\n<li>仅 ARM xT 架构支持</li>\n<li>T = 0: 处理器处于 ARM 模式</li>\n<li>T = 1: 处理器处于 Thumb 模式</li>\n</ul></li>\n<li>mode 位\n<ul class=\"org-ul\">\n<li>处理器模式位</li>\n</ul></li>\n</ul>\n\n\n<p>\nCPSR 寄存器被分成 4 段，C X S F。汇编指令中会用到这些信息。\n</p>\n</div>\n</div>\n<div id=\"outline-container-orgfcb31b9\" class=\"outline-4\">\n<h4 id=\"orgfcb31b9\">异常处理介绍</h4>\n<div class=\"outline-text-4\" id=\"text-orgfcb31b9\">\n<p>\n所有的处理器设计的时候，都会考虑到异常处理的方式。一般 CPU 都会使用中断向量表的方式进行异常处理。中断向量表是在 CPU 设计的时候，就定下来的，是硬件相关的特性。\n当异常发生的时候，CPU 会自动进行一些操作（比如 PC 跳转到对应异常对应的地址执行，还有一些保存上下文相关的操作）。ARM 常见的异常向量表如下图所示\n</p>\n\n<div id=\"orgf77a14f\" class=\"figure\">\n<p><img src=\"/2022/09/27/shadow_register/ivt.png\">\n</p>\n</div>\n\n<p>\n中断向量表是硬件提供给软件自定义异常处理的接口。当异常发生时，CPU 会自动做如下的处理\n</p>\n\n<ul class=\"org-ul\">\n<li>Link Register(R14) 会保存 PC+4/PC+8 的地址</li>\n<li>对应异常模式下的 SPSR = CPSR(保存异常前的处理器的状态)</li>\n<li>修改 CPSR 的模式（低 4 位到低 0 位）</li>\n<li>根据异常类型，跳转到中断向量表中对应的处理函数处</li>\n</ul>\n</div>\n\n<ul class=\"org-ul\">\n<li><a id=\"orgda61466\"></a>配置中断向量表<br>\n<div class=\"outline-text-5\" id=\"text-orgda61466\">\n<p>\n软件需要做的是，编写正确的异常处理函数，并且将其正确的连接到中断向量表\n</p>\n\n<p>\n示例代码如下所示\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> VECTOR_TABLE_BASE 0xD0037400  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Reset_offset 0x0  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Undef_offset 0x4  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SVC_offset 0x8  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Prectch_offset 0xC  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Data_Abort_offset 0x10  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IRQ_offset 0x18  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIQ_offset 0x1C  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PFUNC_Reset (*(unsigned int *)(VECTOR_TABLE_BASE + Reset_offset))  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PFUNC_Undef (*(unsigned int *)(VECTOR_TABLE_BASE + Undef_offset))  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PFUNC_SVC (*(unsigned int *)(VECTOR_TABLE_BASE + SVC_offset))  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PFUNC_Prectch (*(unsigned int *)(VECTOR_TABLE_BASE + Prectch_offset))  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PFUNC_Data_Abort (*(unsigned int *)(VECTOR_TABLE_BASE + Data_Abort_offset))  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PFUNC_IRQ (*(unsigned int *)(VECTOR_TABLE_BASE + IRQ_offset))  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PFUNC_FIQ (*(unsigned int *)(VECTOR_TABLE_BASE + FIQ_offset))  </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">Undef_handle</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;  </span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">Reset_handle</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;  </span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">SVC_handle</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;  </span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">Prectch_handle</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;  </span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">Data_Abort_handle</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;  </span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">IRQ_handle</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vector_table_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>  <span class=\"comment\">//将各个中断处理函数地址正确的链接到向量表  </span></span><br><span class=\"line\">{  </span><br><span class=\"line\">_PFUNC_Reset = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)Reset_handle;  </span><br><span class=\"line\">_PFUNC_Undef = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)Undef_handle;  </span><br><span class=\"line\">_PFUNC_SVC = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)SVC_handle;  </span><br><span class=\"line\">_PFUNC_Prectch = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)Prectch_handle;  </span><br><span class=\"line\">_PFUNC_Data_Abort = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)Data_Abort_handle;  </span><br><span class=\"line\">_PFUNC_IRQ = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)IRQ_handle;  </span><br><span class=\"line\">_PFUNC_FIQ = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)IRQ_handle; <span class=\"comment\">//FIQ、IRQ都是采用IRQ中断  </span></span><br><span class=\"line\">}  </span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</li>\n<li><a id=\"org896c953\"></a>保存现场，在中断处理函数之后，恢复现场<br>\n<div class=\"outline-text-5\" id=\"text-org896c953\">\n<p>\n示例汇编代码如下\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">;; 将 undefined_address 符号对应地址的数据放到 pc 中，其中 undefined_address 为 0x00000004, 在这个地址中存放的数据</span><br><span class=\"line\">;; 为 undefined_handler 的地址</span><br><span class=\"line\">ldr pc, undefined_address                </span><br><span class=\"line\"></span><br><span class=\"line\">;;  undefined address 是一个符号，这个符号对应一个 word 的存储, 存储 undefined_handler 的地址</span><br><span class=\"line\">undefined_address:</span><br><span class=\"line\">\t.word undefined_handler</span><br><span class=\"line\"></span><br><span class=\"line\">undefined_handler:</span><br><span class=\"line\">\t;; 在 CPU 跳转到这行代码之前，CPU 已经完成了我们前面提到的四个步骤</span><br><span class=\"line\">\t;; - Link Register(R14) 会保存 PC+4/PC+8 的地址，此处的 LR 位 undefined 模式下的影子寄存器</span><br><span class=\"line\">\t;; - 对应异常模式下的 SPSR = CPSR(保存异常前的处理器的状态) ,此处的 SPSR 位 undefined 模式下的影子寄存器</span><br><span class=\"line\">\t;; - 修改 CPSR 的模式（低 4 位到低 0 位）</span><br><span class=\"line\">\t;; - 根据异常类型，跳转到中断向量表中对应的处理函数处 (上面的 ldr pc, undefined_address)</span><br><span class=\"line\">\tldr sp, 0x40000000</span><br><span class=\"line\">\t;; 因为异常处理函数中可能会用到 r0-r12, 所以需要将应用状态寄存器保存下来</span><br><span class=\"line\">\t;; lr 是异常处理完后需要返回的地址，同样的需要保存</span><br><span class=\"line\">\t;; - sp = sp - 4; sp = lr (分配 4 个字节，保存 lr)</span><br><span class=\"line\">\t;; - sp = sp - 4; sp = r12 (再分配 4 个字节，保存 r12)</span><br><span class=\"line\">\t;; - ...</span><br><span class=\"line\">\t;; - sp = sp - 4; sp = r0</span><br><span class=\"line\">\tstmdb sp!, {r0-r12, lr}</span><br><span class=\"line\">\t;; 将 cpsr 放到 r0</span><br><span class=\"line\">\t;; 处理异常</span><br><span class=\"line\">\tmrs r0, cpsr</span><br><span class=\"line\">\tldr r1, message</span><br><span class=\"line\">\tbr print_exception</span><br><span class=\"line\"></span><br><span class=\"line\">\t;; 恢复现场（sp 为栈顶指针，指向的是内存地址）</span><br><span class=\"line\">\t;; r0 = sp;  </span><br><span class=\"line\">\t;; r1 = sp + 4; (出栈，将栈空间释放)</span><br><span class=\"line\">\t;; ...</span><br><span class=\"line\">\t;; pc = sp + 4( 这里的 sp + 4 实际指向的是 stmdb 放进去的 lr, 即中断处理完需要返回的地址)</span><br><span class=\"line\">\t;;下面语句中的 '^', 会将当前模式下的 SPSR 恢复到 CPSR 中，即 CPSR = undefined 下的 SPSR</span><br><span class=\"line\">\t;; pc 直接到中断处理完的返回地址，CPSR 也恢复了，R0-R12 也恢复了，所以中断处理完成，返回</span><br><span class=\"line\">\t;; 中断前地方继续执行</span><br><span class=\"line\">\tldmia sp! {r0-r12, pc}^</span><br><span class=\"line\"></span><br><span class=\"line\">message:</span><br><span class=\"line\">\t.string \"undefined instruction\"</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n</body></html>","next":{"title":"一个IC 前端遇到的一些后端的概念","link":"2022/01/11/ic-be"},"plink":"https://kopinions.com/2022/09/27/shadow_register/","toc":[{"id":"org4c686af","title":"缩写","index":"1"},{"id":"org556f67a","title":"设计考虑","index":"2","children":[{"id":"org853b218","title":"设计紧凑","index":"2.1"},{"id":"org47dcf5e","title":"保存CPU状态代价小","index":"2.2"},{"id":"org87107fe","title":"中断处理流程","index":"2.3"}]}],"reading_time":"2307 字约 15 分钟"}