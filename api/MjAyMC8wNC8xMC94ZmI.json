{"title":"OpenGL TransformFeedback 案例和实现考量","date":"2020-04-10T10:40:20.000Z","date_formatted":{"ll":"2020年4月10日","L":"2020/04/10","MM-DD":"04-10"},"link":"2020/04/10/xfb","tags":["Graphics","OpenGL"],"categories":["Graphics","OpenGL"],"updated":"2020-06-29T09:00:00.000Z","content":"<html><head></head><body><div id=\"content\">\n\n<div id=\"outline-container-org88083ce\" class=\"outline-2\">\n<h2 id=\"org88083ce\">xfb 是什么</h2>\n<div class=\"outline-text-2\" id=\"text-org88083ce\">\n\n<div id=\"org792a9fa\" class=\"figure\">\n<p><img src=\"/2020/04/10/xfb/pipeline.png\"><br>\n</p>\n</div>\n\n<p>\nxfb 的全称是 Transform Feedback. Transform Feedback是Shader Model 4.0带来的一个新特性，与其他特性不同的是，它带来了OpenGL/OpenGL ES渲染管线的改变。上图是 OpenGL core 4.3 规范<br>\n中定义的渲染管线。可以在上面的渲染管线中可以看出，在光栅化之前，顶点会进行一个专门的操作 Transform Feedback. 在光栅化之前，所有对顶点进行的操作，<br>\n在 OpenGL 中都称之为 Transform. 这也是 Transform Feedback 中 Transform 的由来。 所谓 Feedback 即反馈，可以看到 Transform Feeback 会将所有进行变换的顶点反馈（Feedback）到<br>\n专用的 Transform Feedback 缓冲区中。应用程序，或者 Vertex shader 可以使用这些已经进行过变换的顶点继续进行后续的绘制工作。<br>\nTransform Feedback能够很好地应用在在粒子系统中，在OpenGL ES中，每个粒子都可能是一个GL_Point，在GPU中就是一个顶点。如果没有Transform Feedback，在每一帧的绘制中，<br>\n开发者可能需要为粒子准备不同的VBO，来描述粒子的变换，而VBO从客户端上传到服务器端需要消耗很大的时间。随着Transform feedback的到来，我们可以一次性的把顶点数据变换好然后输出到Transform Feedback缓存中，<br>\n然后这个缓存就可以给后面的很多帧使用。这种2-pass的绘制解决方案能极大地提高应用程序的3D图形的效率。<br>\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-orga22c14d\" class=\"outline-2\">\n<h2 id=\"orga22c14d\">xfb 如何使用</h2>\n<div class=\"outline-text-2\" id=\"text-orga22c14d\">\n<p>\nxfb 的使用主要分为几个重要的阶段<br>\n</p>\n<ol class=\"org-ol\">\n<li><p>\n准备 xfb Buffer<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">GLuint xfbbuffer;</span><br><span class=\"line\">GLfloat data[<span class=\"number\">3</span>] = {<span class=\"number\">1.0f</span>, <span class=\"number\">2.0f</span>, <span class=\"number\">3.0f</span>};</span><br><span class=\"line\"><span class=\"comment\">// 生成 xfb buffer 对象的唯一标识</span></span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;xfbbuffer);</span><br><span class=\"line\"><span class=\"comment\">// 创建 xfbbuffer 对应的缓冲区 </span></span><br><span class=\"line\">glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, xfbbuffer);</span><br><span class=\"line\"><span class=\"comment\">// 创建 buffer 存储对象，并使用 data 进行初始化</span></span><br><span class=\"line\">glBufferData(GL_TRANSFORM_FEEDBACK_BUFFER, <span class=\"keyword\">sizeof</span>(data), <span class=\"literal\">NULL</span>, GL_STATIC_READ);</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n<li><p>\n准备 xfb Object<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">GLuint xfbname;</span><br><span class=\"line\"><span class=\"comment\">// 生成 xfb 对象的唯一标识</span></span><br><span class=\"line\">glGenTransformFeedbacks(<span class=\"number\">1</span>, &amp;xfbname);</span><br><span class=\"line\"><span class=\"comment\">// 创建或者初始化 xfb 对象</span></span><br><span class=\"line\">glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, xfbname);</span><br><span class=\"line\"><span class=\"comment\">// 因为 xfb 的机制允许有多个 buffer 存在，所以这里我们只使用第一个 buffer, 所以我们将 xfbbuffer 绑定到 xfb 缓冲区数组的第一个绑定点。</span></span><br><span class=\"line\">glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class=\"number\">0</span>, xfbbuffer);</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n<li><p>\n准备 shader<br>\nvertex shader<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 430</span></span><br><span class=\"line\">out vec2 max_value;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> {</span><br><span class=\"line\">  max_value = vec2(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">  gl_Position = vec4(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div>\n<p>\nfragment shader<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 430</span></span><br><span class=\"line\">out vec4 color;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> {</span><br><span class=\"line\">  color = vec4(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\n配置 xfb 变量<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> * varyings[] = {</span><br><span class=\"line\">\t\t    <span class=\"string\">\"max_value\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">};</span><br><span class=\"line\">glTransformFeedbackVarings(p, <span class=\"keyword\">sizeof</span>(varyings)/<span class=\"keyword\">sizeof</span>(varyings[<span class=\"number\">0</span>]), varyings, GL_INTERLEAVED_ATTRIBS);</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\n编译 &amp; 链接<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">GLuint v = glCreateShader(GL_VERTEX_SHADER);</span><br><span class=\"line\">glShaderSource(vert);</span><br><span class=\"line\">glCompileShader(v);</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint f = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class=\"line\">glShaderSource(vert);</span><br><span class=\"line\">glCompileShader(v);</span><br><span class=\"line\"></span><br><span class=\"line\">GLunit p = glCreateProgram();</span><br><span class=\"line\">glAttachShader(p, v);</span><br><span class=\"line\">glAttachShader(p, f);</span><br><span class=\"line\"></span><br><span class=\"line\">glLinkProgram(p);</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\n开启 xfb 绘制<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, xfbname);</span><br><span class=\"line\">glBeginTransformFeedback(GL_POINTS);</span><br><span class=\"line\">glDrawArrays(GL_POINTS, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">glEndTransformFeedbak();</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\n获取 xfb buffer<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">GLfloat buf[<span class=\"number\">3</span>];</span><br><span class=\"line\">glGetBufferSubData(GL_TRANSFORM_FEEDBACK_BUFFER, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(buf), fb);</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n</ol>\n</div>\n</div>\n\n<div id=\"outline-container-org7457783\" class=\"outline-2\">\n<h2 id=\"org7457783\">xfb 用户态驱动层如何实现</h2>\n<div class=\"outline-text-2\" id=\"text-org7457783\">\n<p>\n用户态驱动主要完成信息的收集以及下发工作。所以用户态主要完成的就是在 xfb 使用过程中调用 API 的实现，以及 API 涉及的信息的收集以及整理的工作。<br>\n</p>\n\n<ol class=\"org-ol\">\n<li><p>\nglBindBuffer 处理 GL_TRANSFORM_FEEDBACK_BUFFER 的绑定<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">_mesa_BindBuffer(GLenum target, GLuint buffer) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(target) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> GL_TRANSFORM_FEEDBACK_BUFFER:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!_mesa_validate_buffer_range_xfb(ctx,</span><br><span class=\"line\">\t\t\t\t\t   ctx-&gt;TransformFeedback.CurrentObject,</span><br><span class=\"line\">\t\t\t\t\t   index, bufObj, offset, size,</span><br><span class=\"line\">\t\t\t\t\t   <span class=\"literal\">false</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      _mesa_bind_buffer_range_xfb(ctx, ctx-&gt;TransformFeedback.CurrentObject,</span><br><span class=\"line\">\t\t\t\t  index, bufObj, offset, size);}</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\nglGenTransformFeedbacks 生成 xfb 的唯一标识<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> GLAPIENTRY</span><br><span class=\"line\">_mesa_GenTransformFeedbacks(GLsizei n, GLuint *names)</span><br><span class=\"line\">{</span><br><span class=\"line\">   GET_CURRENT_CONTEXT(ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* GenTransformFeedbacks should just reserve the object names that a</span></span><br><span class=\"line\"><span class=\"comment\">    * subsequent call to BindTransformFeedback should actively create. For</span></span><br><span class=\"line\"><span class=\"comment\">    * the sake of simplicity, we reserve the names and create the objects</span></span><br><span class=\"line\"><span class=\"comment\">    * straight away.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">   create_transform_feedbacks(ctx, n, names, <span class=\"literal\">false</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\nglBindTransformFeedback 绑定当前操作 xfb 对象<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> GLAPIENTRY</span><br><span class=\"line\">_mesa_BindTransformFeedback(GLenum target, GLuint name)</span><br><span class=\"line\">{</span><br><span class=\"line\">  GET_CURRENT_CONTEXT(ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target != GL_TRANSFORM_FEEDBACK) {</span><br><span class=\"line\">    _mesa_error(ctx, GL_INVALID_ENUM, <span class=\"string\">\"glBindTransformFeedback(target)\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_mesa_is_xfb_active_and_unpaused(ctx)) {</span><br><span class=\"line\">    _mesa_error(ctx, GL_INVALID_OPERATION,</span><br><span class=\"line\">\t\t<span class=\"string\">\"glBindTransformFeedback(transform is active, or not paused)\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  bind_transform_feedback(ctx, name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\nglBindBufferBase 处理 GL_TRANSFORM_FEEDBACK_BUFFER 的绑定<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> GLAPIENTRY</span><br><span class=\"line\">_mesa_BindBufferBase(GLenum target, GLuint index, GLuint buffer)</span><br><span class=\"line\">{</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">switch</span> (target) {</span><br><span class=\"line\">   <span class=\"keyword\">case</span> GL_TRANSFORM_FEEDBACK_BUFFER:</span><br><span class=\"line\">      _mesa_bind_buffer_base_transform_feedback(ctx,</span><br><span class=\"line\">\t\t\t\t\t\tctx-&gt;TransformFeedback.CurrentObject,</span><br><span class=\"line\">\t\t\t\t\t\tindex, bufObj, <span class=\"literal\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      _mesa_error(ctx, GL_INVALID_ENUM, <span class=\"string\">\"glBindBufferBase(target)\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n\n<li><p>\nglBeginTransformFeedback &amp; glEndTransformFeedback<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> GLAPIENTRY</span><br><span class=\"line\">_mesa_BeginTransformFeedback(GLenum mode)</span><br><span class=\"line\">{</span><br><span class=\"line\">  GET_CURRENT_CONTEXT(ctx);</span><br><span class=\"line\">  begin_transform_feedback(ctx, mode, <span class=\"literal\">false</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> ALWAYS_INLINE <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">begin_transform_feedback</span><span class=\"params\">(<span class=\"keyword\">struct</span> gl_context *ctx, GLenum mode, <span class=\"type\">bool</span> no_error)</span></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gl_transform_feedback_object</span> *<span class=\"title\">obj</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gl_transform_feedback_info</span> *<span class=\"title\">info</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gl_program</span> *<span class=\"title\">source</span>;</span></span><br><span class=\"line\">  GLuint i;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> vertices_per_prim;</span><br><span class=\"line\"></span><br><span class=\"line\">  obj = ctx-&gt;TransformFeedback.CurrentObject;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Figure out what pipeline stage is the source of data for transform</span></span><br><span class=\"line\"><span class=\"comment\">   * feedback.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  source = get_xfb_source(ctx);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!no_error &amp;&amp; source == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">    _mesa_error(ctx, GL_INVALID_OPERATION,</span><br><span class=\"line\">\t\t<span class=\"string\">\"glBeginTransformFeedback(no program active)\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  info = source-&gt;sh.LinkedTransformFeedback;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!no_error &amp;&amp; info-&gt;NumOutputs == <span class=\"number\">0</span>) {</span><br><span class=\"line\">    _mesa_error(ctx, GL_INVALID_OPERATION,</span><br><span class=\"line\">\t\t<span class=\"string\">\"glBeginTransformFeedback(no varyings to record)\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (mode) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> GL_POINTS:</span><br><span class=\"line\">      vertices_per_prim = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> GL_LINES:</span><br><span class=\"line\">      vertices_per_prim = <span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> GL_TRIANGLES:</span><br><span class=\"line\">      vertices_per_prim = <span class=\"number\">3</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!no_error) {</span><br><span class=\"line\">\t_mesa_error(ctx, GL_INVALID_ENUM, <span class=\"string\">\"glBeginTransformFeedback(mode)\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">\t<span class=\"comment\">/* Stop compiler warnings */</span></span><br><span class=\"line\">\tunreachable(<span class=\"string\">\"Error in API use when using KHR_no_error\"</span>);</span><br><span class=\"line\">      }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!no_error) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj-&gt;Active) {</span><br><span class=\"line\">      _mesa_error(ctx, GL_INVALID_OPERATION,</span><br><span class=\"line\">\t\t  <span class=\"string\">\"glBeginTransformFeedback(already active)\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; ctx-&gt;Const.MaxTransformFeedbackBuffers; i++) {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((info-&gt;ActiveBuffers &gt;&gt; i) &amp; <span class=\"number\">1</span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (obj-&gt;BufferNames[i] == <span class=\"number\">0</span>) {</span><br><span class=\"line\">\t  _mesa_error(ctx, GL_INVALID_OPERATION,</span><br><span class=\"line\">\t\t      <span class=\"string\">\"glBeginTransformFeedback(binding point %d does not \"</span></span><br><span class=\"line\">\t\t      <span class=\"string\">\"have a buffer object bound)\"</span>, i);</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  FLUSH_VERTICES(ctx, <span class=\"number\">0</span>);</span><br><span class=\"line\">  ctx-&gt;NewDriverState |= ctx-&gt;DriverFlags.NewTransformFeedback;</span><br><span class=\"line\"></span><br><span class=\"line\">  obj-&gt;Active = GL_TRUE;</span><br><span class=\"line\">  ctx-&gt;TransformFeedback.Mode = mode;</span><br><span class=\"line\"></span><br><span class=\"line\">  compute_transform_feedback_buffer_sizes(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_mesa_is_gles3(ctx)) {</span><br><span class=\"line\">    <span class=\"comment\">/* In GLES3, we are required to track the usage of the transform</span></span><br><span class=\"line\"><span class=\"comment\">     * feedback buffer and report INVALID_OPERATION if a draw call tries to</span></span><br><span class=\"line\"><span class=\"comment\">     * exceed it.  So compute the maximum number of vertices that we can</span></span><br><span class=\"line\"><span class=\"comment\">     * write without overflowing any of the buffers currently being used for</span></span><br><span class=\"line\"><span class=\"comment\">     * feedback.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> max_vertices</span><br><span class=\"line\">\t= _mesa_compute_max_transform_feedback_vertices(ctx, obj, info);</span><br><span class=\"line\">    obj-&gt;GlesRemainingPrims = max_vertices / vertices_per_prim;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj-&gt;program != source) {</span><br><span class=\"line\">    ctx-&gt;NewDriverState |= ctx-&gt;DriverFlags.NewTransformFeedbackProg;</span><br><span class=\"line\">    _mesa_reference_program_(ctx, &amp;obj-&gt;program, source);</span><br><span class=\"line\">    obj-&gt;program = source;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(ctx-&gt;Driver.BeginTransformFeedback);</span><br><span class=\"line\">  ctx-&gt;Driver.BeginTransformFeedback(ctx, mode, obj);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">end_transform_feedback</span><span class=\"params\">(<span class=\"keyword\">struct</span> gl_context *ctx,</span></span><br><span class=\"line\"><span class=\"params\">\t\t       <span class=\"keyword\">struct</span> gl_transform_feedback_object *obj)</span></span><br><span class=\"line\">{</span><br><span class=\"line\">   FLUSH_VERTICES(ctx, <span class=\"number\">0</span>);</span><br><span class=\"line\">   ctx-&gt;NewDriverState |= ctx-&gt;DriverFlags.NewTransformFeedback;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert(ctx-&gt;Driver.EndTransformFeedback);</span><br><span class=\"line\">   ctx-&gt;Driver.EndTransformFeedback(ctx, obj);</span><br><span class=\"line\"></span><br><span class=\"line\">   _mesa_reference_program_(ctx, &amp;obj-&gt;program, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">   ctx-&gt;TransformFeedback.CurrentObject-&gt;Active = GL_FALSE;</span><br><span class=\"line\">   ctx-&gt;TransformFeedback.CurrentObject-&gt;Paused = GL_FALSE;</span><br><span class=\"line\">   ctx-&gt;TransformFeedback.CurrentObject-&gt;EndedAnytime = GL_TRUE;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> GLAPIENTRY</span><br><span class=\"line\">_mesa_EndTransformFeedback(<span class=\"type\">void</span>)</span><br><span class=\"line\">{</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gl_transform_feedback_object</span> *<span class=\"title\">obj</span>;</span></span><br><span class=\"line\">   GET_CURRENT_CONTEXT(ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">   obj = ctx-&gt;TransformFeedback.CurrentObject;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!obj-&gt;Active) {</span><br><span class=\"line\">      _mesa_error(ctx, GL_INVALID_OPERATION,</span><br><span class=\"line\">\t\t  <span class=\"string\">\"glEndTransformFeedback(not active)\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   }</span><br><span class=\"line\"></span><br><span class=\"line\">   end_transform_feedback(ctx, obj);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n<li>glDraw* 相关函数进行修改<br></li>\n</ol>\n<p>\n主要的内容就在第 70 行的 st_transform_feedback_draw_init<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">st_draw_vbo</span><span class=\"params\">(<span class=\"keyword\">struct</span> gl_context *ctx,</span></span><br><span class=\"line\"><span class=\"params\">\t    <span class=\"type\">const</span> <span class=\"keyword\">struct</span> _mesa_prim *prims,</span></span><br><span class=\"line\"><span class=\"params\">\t    GLuint nr_prims,</span></span><br><span class=\"line\"><span class=\"params\">\t    <span class=\"type\">const</span> <span class=\"keyword\">struct</span> _mesa_index_buffer *ib,</span></span><br><span class=\"line\"><span class=\"params\">\t    GLboolean index_bounds_valid,</span></span><br><span class=\"line\"><span class=\"params\">\t    GLuint min_index,</span></span><br><span class=\"line\"><span class=\"params\">\t    GLuint max_index,</span></span><br><span class=\"line\"><span class=\"params\">\t    GLuint num_instances,</span></span><br><span class=\"line\"><span class=\"params\">\t    GLuint base_instance,</span></span><br><span class=\"line\"><span class=\"params\">\t    <span class=\"keyword\">struct</span> gl_transform_feedback_object *tfb_vertcount,</span></span><br><span class=\"line\"><span class=\"params\">\t    <span class=\"type\">unsigned</span> stream)</span></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_context</span> *<span class=\"title\">st</span> =</span> st_context(ctx);</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_draw_info</span> <span class=\"title\">info</span>;</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> i;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  prepare_draw(st, ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Initialize pipe_draw_info. */</span></span><br><span class=\"line\">  info.primitive_restart = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  info.vertices_per_patch = ctx-&gt;TessCtrlProgram.patch_vertices;</span><br><span class=\"line\">  info.indirect = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  info.count_from_stream_output = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  info.restart_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">  info.start_instance = base_instance;</span><br><span class=\"line\">  info.instance_count = num_instances;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ib) {</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gl_buffer_object</span> *<span class=\"title\">bufobj</span> =</span> ib-&gt;obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get index bounds for user buffers. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!index_bounds_valid &amp;&amp; st-&gt;draw_needs_minmax_index) {</span><br><span class=\"line\">      vbo_get_minmax_indices(ctx, prims, ib, &amp;min_index, &amp;max_index,</span><br><span class=\"line\">\t\t\t     nr_prims);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    info.index_size = <span class=\"number\">1</span> &lt;&lt; ib-&gt;index_size_shift;</span><br><span class=\"line\">    info.min_index = min_index;</span><br><span class=\"line\">    info.max_index = max_index;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bufobj) {</span><br><span class=\"line\">      <span class=\"comment\">/* indices are in a real VBO */</span></span><br><span class=\"line\">      info.has_user_indices = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      info.index.resource = st_buffer_object(bufobj)-&gt;buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* Return if the bound element array buffer doesn't have any backing</span></span><br><span class=\"line\"><span class=\"comment\">       * storage. (nothing to do)</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!info.index.resource)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      start = pointer_to_offset(ib-&gt;ptr) &gt;&gt; ib-&gt;index_size_shift;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">      <span class=\"comment\">/* indices are in user space memory */</span></span><br><span class=\"line\">      info.has_user_indices = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      info.index.user = ib-&gt;ptr;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    setup_primitive_restart(ctx, &amp;info);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    info.index_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    info.has_user_indices = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Transform feedback drawing is always non-indexed. */</span></span><br><span class=\"line\">    <span class=\"comment\">/* Set info.count_from_stream_output. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tfb_vertcount) {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!st_transform_feedback_draw_init(tfb_vertcount, stream, &amp;info))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* do actual drawing */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nr_prims; i++) {</span><br><span class=\"line\">    info.count = prims[i].count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Skip no-op draw calls. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!info.count &amp;&amp; !tfb_vertcount)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    info.mode = translate_prim(ctx, prims[i].mode);</span><br><span class=\"line\">    info.start = start + prims[i].start;</span><br><span class=\"line\">    info.index_bias = prims[i].basevertex;</span><br><span class=\"line\">    info.drawid = prims[i].draw_id;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ib) {</span><br><span class=\"line\">      info.min_index = info.start;</span><br><span class=\"line\">      info.max_index = info.start + info.count - <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ST_DEBUG &amp; DEBUG_DRAW) {</span><br><span class=\"line\">      debug_printf(<span class=\"string\">\"st/draw: mode %s  start %u  count %u  index_size %d\\n\"</span>,</span><br><span class=\"line\">\t\t   u_prim_name(info.mode),</span><br><span class=\"line\">\t\t   info.start,</span><br><span class=\"line\">\t\t   info.count,</span><br><span class=\"line\">\t\t   info.index_size);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Don't call u_trim_pipe_prim. Drivers should do it if they need it. */</span></span><br><span class=\"line\">    cso_draw_vbo(st-&gt;cso_context, &amp;info);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"title function_\">st_transform_feedback_draw_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> gl_transform_feedback_object *obj,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t<span class=\"type\">unsigned</span> stream, <span class=\"keyword\">struct</span> pipe_draw_info *out)</span></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_transform_feedback_object</span> *<span class=\"title\">sobj</span> =</span></span><br><span class=\"line\">      st_transform_feedback_object(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">  out-&gt;count_from_stream_output = sobj-&gt;draw_count[stream];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> out-&gt;count_from_stream_output != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</div>\n</div>\n</body></html>","prev":{"title":"cts 的测试范围","link":"2020/06/03/cts-coverage"},"next":{"title":"用 orgmode 在 hexo 上写博客","link":"2020/03/05/hexo"},"plink":"https://kopinions.com/2020/04/10/xfb/","toc":[{"id":"org88083ce","title":"xfb 是什么","index":"1"},{"id":"orga22c14d","title":"xfb 如何使用","index":"2"},{"id":"org7457783","title":"xfb 用户态驱动层如何实现","index":"3"}],"reading_time":"1629 字约 11 分钟"}