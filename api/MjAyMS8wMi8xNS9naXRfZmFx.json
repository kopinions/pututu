{"title":"Git 常见问题","date":"2021-02-15T00:00:00.000Z","date_formatted":{"ll":"2021年2月15日","L":"2021/02/15","MM-DD":"02-15"},"link":"2021/02/15/git_faq","tags":["git"],"categories":["git"],"updated":"2021-02-22T00:00:00.000Z","content":"<html><head></head><body><div id=\"content\">\n\n<div id=\"outline-container-orgdb6fae1\" class=\"outline-2\">\n<h2 id=\"orgdb6fae1\">交互的添加代码（想加什么就加什么）</h2>\n<div class=\"outline-text-2\" id=\"text-orgdb6fae1\">\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git add -p</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n在交互模形式下，支持如下所示的一些命令：<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight text\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">y - stage this hunk(添加当前代码块)</span><br><span class=\"line\">n - do not stage this hunk(不添加当前代码块)</span><br><span class=\"line\">q - quit; do not stage this hunk or any of the remaining ones(退出当前交互式添加)</span><br><span class=\"line\">a - stage this hunk and all later hunks in the file(当前文件到结束的所有内容都添加)</span><br><span class=\"line\">d - do not stage this hunk or any of the later hunks in the file(当前文件到结束，都不添加)</span><br><span class=\"line\">g - select a hunk to go to(在多个修改之间进行跳转，进行编辑)</span><br><span class=\"line\">/ - search for a hunk matching the given regex(同上，使用正则表达式跳转)</span><br><span class=\"line\">j - leave this hunk undecided, see next undecided hunk(跳转下一个没有添加的代码块)</span><br><span class=\"line\">J - leave this hunk undecided, see next hunk(跳转到下一个代码块)</span><br><span class=\"line\">K - leave this hunk undecided, see previous hunk(跳转到上一个代码块)</span><br><span class=\"line\">e - manually edit the current hunk(编辑当前代码块)</span><br><span class=\"line\">? - print help</span><br></pre></td></tr></tbody></table></figure>\n</div>\n<p>\ngit 会将所有更改拆分成小块，然后对每一个小的代码会，询问你是否添加，以及更改当前代码块。<br>\n</p>\n</div>\n</div>\n\n\n<div id=\"outline-container-org3f39c92\" class=\"outline-2\">\n<h2 id=\"org3f39c92\">很大一块代码，如何分开添加，提交</h2>\n<div class=\"outline-text-2\" id=\"text-org3f39c92\">\n<p>\n很多时候我们发现即便我们使用交互式的方式去提交代码，但是我们的一段代码中，还是会出现不应该出现在一个 commit 记录中的代码，这种<br>\n情况下，我们可以使用两种方式来进行添加。<br>\n</p>\n\n<ol class=\"org-ol\">\n<li><p>\n交互式添加中的 split 方式<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight diff\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"addition\">+ 这是 story 1 中添加的代码。</span></span><br><span class=\"line\">这里没有发生过变更</span><br><span class=\"line\"><span class=\"addition\">+ 这个是修复代码，但是不应该出现在本次的提交中。</span></span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n对于上面的代码段，在交互添加的时候，这段代码会一起来让用户决定是否添加到当前提交的变更中。但是我们<br>\n变更中想添加第一行。此时我们可以使用 s(split) 命令。split 会变成如下的提示方式，让用户进行选择<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight diff\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--- a/xxxx</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/xxxx</span></span><br><span class=\"line\"><span class=\"meta\">@@ -12,2 +12,3 @@</span></span><br><span class=\"line\"><span class=\"addition\">+ 这是 story 1 中添加的代码。</span></span><br><span class=\"line\">  这里没有发生过变更</span><br><span class=\"line\"></span><br><span class=\"line\">(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?n</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight diff\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--- a/xxxx</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/xxxx</span></span><br><span class=\"line\"><span class=\"meta\">@@ -12,2 +12,3 @@</span></span><br><span class=\"line\"><span class=\"addition\">+ 这个是修复代码，但是不应该出现在本次的提交中。</span></span><br><span class=\"line\"></span><br><span class=\"line\">(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?n</span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n<li><p>\n手动编辑当前代码块<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight diff\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--- a/xxxx</span></span><br><span class=\"line\"><span class=\"comment\">+++ b/xxxx</span></span><br><span class=\"line\"><span class=\"meta\">@@ -12,0 +12,7 @@</span></span><br><span class=\"line\"><span class=\"addition\">+ 这段代码非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 你看我大不大</span></span><br><span class=\"line\"><span class=\"addition\">+ 到这里就结束了</span></span><br><span class=\"line\"><span class=\"addition\">+ 不应该出现在这里的代码，我们不应该添加</span></span><br><span class=\"line\">(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n此时我们使用 e(edit) 命令进行相应的处理。在 e 的时候，会有如下的提示：<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight diff\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"># Manual hunk edit mode -- see bottom for a quick guide.</span><br><span class=\"line\">1 @@ -190,6 +788,11 @@</span><br><span class=\"line\"><span class=\"addition\">+ 这段代码非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 你看我大不大</span></span><br><span class=\"line\"><span class=\"deletion\">- 删掉了不大的代码，暂时也不需要添加</span></span><br><span class=\"line\"><span class=\"addition\">+ 到这里就结束了</span></span><br><span class=\"line\"><span class=\"addition\">+ 不应该出现在这里的代码，我们不应该添加</span></span><br><span class=\"line\"># ---</span><br><span class=\"line\"># To remove '-' lines, make them ' ' lines (context). \"如果不想添加 删除掉的某一行，将 - 替换成 ' ' 空格\"</span><br><span class=\"line\"># To remove '+' lines, delete them.(如果不像要 + 行，直接删除)</span><br><span class=\"line\"># Lines starting with # will be removed.</span><br><span class=\"line\">#</span><br><span class=\"line\"># If the patch applies cleanly, the edited hunk will immediately be</span><br><span class=\"line\"># marked for staging.</span><br><span class=\"line\"># If it does not apply cleanly, you will be given an opportunity to</span><br><span class=\"line\"># edit again.  If all lines of the hunk are removed, then the edit is</span><br><span class=\"line\"># aborted and the hunk is left unchanged.</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n此时会进入编辑模式，会根据 git 配置的编辑器，启动编辑器。对于上面的代码块，我们只需要删除“不应该出现在这里代码”，然后将其标示为：如下的形式，保存即可。<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight diff\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"># Manual hunk edit mode -- see bottom for a quick guide.</span><br><span class=\"line\">1 @@ -190,6 +788,11 @@</span><br><span class=\"line\"><span class=\"addition\">+ 这段代码非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 非常非常大</span></span><br><span class=\"line\"><span class=\"addition\">+ 你看我大不大</span></span><br><span class=\"line\">删掉了不大的代码，暂时也不需要添加</span><br><span class=\"line\"><span class=\"addition\">+ 到这里就结束了</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</div></li>\n</ol>\n</div>\n</div>\n\n\n\n\n\n\n<div id=\"outline-container-org6cd0477\" class=\"outline-2\">\n<h2 id=\"org6cd0477\">如何管理 stash</h2>\n<div class=\"outline-text-2\" id=\"text-org6cd0477\">\n<p>\n我们可以通过 git 的 stash 机制来完成一些临时更改的暫存操作。也可以临时的找回这些修改。<br>\n</p>\n</div>\n<div id=\"outline-container-org4937e17\" class=\"outline-3\">\n<h3 id=\"org4937e17\">压栈 &amp; 弹栈</h3>\n<div class=\"outline-text-3\" id=\"text-org4937e17\">\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git stash</span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orge769176\" class=\"outline-3\">\n<h3 id=\"orge769176\">查看 stash</h3>\n<div class=\"outline-text-3\" id=\"text-orge769176\">\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git stash list</span><br><span class=\"line\">git stash show <span class=\"string\">\"stach@{1}\"</span></span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgdf3babb\" class=\"outline-3\">\n<h3 id=\"orgdf3babb\">冲突处理</h3>\n<div class=\"outline-text-3\" id=\"text-orgdf3babb\">\n<p>\n很多时候我们的工作流程可能是如下的：<br>\n</p>\n<ol class=\"org-ol\">\n<li>别人有更改了，我的代码还没有改完，此时我们将我们本地的代码 stash 掉<br></li>\n<li>将别人的代码 git pull –reb 到本地。（检查是否有冲突）<br></li>\n<li>将我们的修改 git stash pop 出来<br></li>\n</ol>\n\n<p>\n有些时候我们发现，我们 stash pop 出来我们修改的时候，和远端最新的代码有冲突。这种情况如何处理？<br>\n</p>\n\n<p>\n当我们在 stash pop 的时候，git 会发现冲突，所以这种情况下 git stash 中的记录，不会被删除。<br>\n这种情况下我们需要首先处理 stash pop 后的冲突问题。接下来，因为 git stash 中的记录没有被删除（因为 conflict），但是，其实我们<br>\n已经处理过冲突了，此时，我们只需要使用 git stash drop 将 stash 中的最近的记录删掉就可以了。<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git stash drop</span><br></pre></td></tr></tbody></table></figure>\n</div>\n<p>\n首先我们需要<br>\n</p>\n</div>\n</div>\n</div>\n\n\n<div id=\"outline-container-org2a65278\" class=\"outline-2\">\n<h2 id=\"org2a65278\">如何找到丢失的记录</h2>\n<div class=\"outline-text-2\" id=\"text-org2a65278\">\n<p>\n很多时候，我们一顿操作猛如虎，结果发现我们的有些记录不见了，这种时候，有一个命令可以帮我们看下是否能找到我们的提交记录。<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\ngit 会将我们对本地仓库的一些更新操作记录下来。我们可以通过这些记录，就可以通过一些命令将东西找回来<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git cherry-pick xxxx</span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</div>\n\n\n<div id=\"outline-container-orgea3fc7a\" class=\"outline-2\">\n<h2 id=\"orgea3fc7a\">如何合并提交</h2>\n<div class=\"outline-text-2\" id=\"text-orgea3fc7a\">\n<p>\n多人协作的项目，我们需要有一个良好的协作习惯－－－我们在 push 代码之前，一定要确保我们的代码是可以正常编译的。所以很多时候我们的 push 代码的流程可能是<br>\n</p>\n<ol class=\"org-ol\">\n<li>git pull –reb (获取远端最新的提交)<br></li>\n<li>make &amp;&amp; make test<br></li>\n<li>如果测试通过 git push, 否则修复<br></li>\n</ol>\n\n<p>\n此时突然发现，远端的代码发生了变更，导致我们本地的代码不能正常的编译。这种情况下，我们往往有两种选择：<br>\n第一种：修复编译失败，并且提交一个新的 commit, 并加上类似于 fix compile error after merge 等等的信息。<br>\n</p>\n\n<p>\n第二种，也是本人比较推荐的一种是修复编译失败，然后将修复编辑的更改 amend(修正) 当前提交上。 因为本质上来讲，这个是属于我们前面提交的 commit 基于的版本是有<br>\n歧义的版本。所以我们这些更改编译错误，其实是在修复这个歧义。另外 fix compile error 这种其实很难提供这种上下文，来说明这次提交做了什么事情。所以个人更加倾向使用这种方式。<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit --amend --no-edit</span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</div>\n\n\n<div id=\"outline-container-orgd25e452\" class=\"outline-2\">\n<h2 id=\"orgd25e452\">如何覆盖远程提交记录（不推荐）</h2>\n<div class=\"outline-text-2\" id=\"text-orgd25e452\">\n<p>\n很多时候我们发现一些更改不需要存在，但是我们发现我们已经提交到远端了，这种情况下我们可以使用强制覆盖的方式来覆盖远端的记录<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git push -f</span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</div>\n\n\n<div id=\"outline-container-org71b7379\" class=\"outline-2\">\n<h2 id=\"org71b7379\">该删的代码就删，有各种机制找回</h2>\n<div class=\"outline-text-2\" id=\"text-org71b7379\">\n<p>\n很多时候，我们代码种出现了各种注释掉的代码，这些代码往往是可能不需要的代码，但是因为考虑到，后续可能还可能会参考类似代码，所以很多人选择将代码注释掉。<br>\n但是这种做法时间长了之后，会让我们的代码变得比较臃肿。这种情况可以直接删除代码，我们有各种个样的机制来找回我们删除的代码，如下就有几种方式<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 展示当前文件发生过的所有更改的 commit 记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -- file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 展示文件的每一行的更改记录</span></span><br><span class=\"line\"></span><br><span class=\"line\">git blame file</span><br></pre></td></tr></tbody></table></figure>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org6570d8d\" class=\"outline-2\">\n<h2 id=\"org6570d8d\">回滚操作</h2>\n<div class=\"outline-text-2\" id=\"text-org6570d8d\">\n<p>\n当团队比较大的时候，我们自己的提交可能有时候会让持续集成（CI)的测试失败。 很多人会被 block 不能提交，这种情况下，一个快速<br>\n的修复方式就是把我们自己导致失败的那次提交回滚。然后在本地构造相应的环境进行修复。常见的操作步骤如下：<br>\n</p>\n\n<ol class=\"org-ol\">\n<li>git log 找到导致失败的 commit hash<br></li>\n<li>回滚（git revert hash)<br></li>\n<li>git push<br></li>\n</ol>\n\n<p>\n通过上面三个步骤，我们完成了回滚我们的提交。但是如何将我们上次的更改再次拿回来，然后在本地进行相应的测试修复，一般有几种做法：<br>\n</p>\n\n<ol class=\"org-ol\">\n<li>git cherry-pick commit-hash&amp;&amp; git reset HEAD~<br></li>\n<li>git show commit-hash |git apply<br></li>\n</ol>\n\n<p>\n第一种方式，将原来的提交继续拿到本地，然后可以 reset 或者不 reset, 然后通过 –amend 的方式来进行修复。<br>\n第二种方式，直接将出问题的变更重新应用到当前工作区，然后，需要修复后，重新添加更改，提交。<br>\n</p>\n</div>\n</div>\n</div>\n</body></html>","prev":{"title":"理解计算机大小端（字节序）","link":"2021/03/11/endianess"},"next":{"title":"macos 蓝牙键盘切换乱码问题记录","link":"2020/06/16/garbled-code-macos"},"plink":"https://kopinions.com/2021/02/15/git_faq/","toc":[{"id":"orgdb6fae1","title":"交互的添加代码（想加什么就加什么）","index":"1"},{"id":"org3f39c92","title":"很大一块代码，如何分开添加，提交","index":"2"},{"id":"org6cd0477","title":"如何管理 stash","index":"3","children":[{"id":"org4937e17","title":"压栈 &amp; 弹栈","index":"3.1"},{"id":"orge769176","title":"查看 stash","index":"3.2"},{"id":"orgdf3babb","title":"冲突处理","index":"3.3"}]},{"id":"org2a65278","title":"如何找到丢失的记录","index":"4"},{"id":"orgea3fc7a","title":"如何合并提交","index":"5"},{"id":"orgd25e452","title":"如何覆盖远程提交记录（不推荐）","index":"6"},{"id":"org71b7379","title":"该删的代码就删，有各种机制找回","index":"7"},{"id":"org6570d8d","title":"回滚操作","index":"8"}],"reading_time":"2296 字约 15 分钟"}