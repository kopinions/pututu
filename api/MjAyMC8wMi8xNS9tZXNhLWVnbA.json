{"title":"Mesa3D 详解","date":"2020-02-15T12:40:20.000Z","date_formatted":{"ll":"2020年2月15日","L":"2020/02/15","MM-DD":"02-15"},"link":"2020/02/15/mesa-egl","tags":["gpu","graphic","mesa","opengl","vulkan"],"categories":["graphics","mesa"],"updated":"2020-02-15T00:00:00.000Z","content":"<html><head></head><body><div id=\"content\">\n\n<div id=\"outline-container-orgf777b56\" class=\"outline-2\">\n<h2 id=\"orgf777b56\">mesa 架构详解</h2>\n<div class=\"outline-text-2\" id=\"text-orgf777b56\">\n<p>\nmesa 也称作 Mesa3D 是一个 OpenGL, Vulkan 等规范的一个开源实现。mesa 将这些规范翻译到针对不同硬件平台的实现。mesa 作为一个开源图形技术栈，在整个 linux 图形栈中，得位置如下图所示<br>\n</p>\n\n<div id=\"org42debdb\" class=\"figure\">\n<p><img src=\"/2020/02/15/mesa-egl/linux-graphic-stack.png\"><br>\n</p>\n</div>\n</div>\n<div id=\"outline-container-orga1964c7\" class=\"outline-3\">\n<h3 id=\"orga1964c7\">mesa 架构</h3>\n</div>\n\n<div id=\"outline-container-orgc29fcc7\" class=\"outline-3\">\n<h3 id=\"orgc29fcc7\">EGL 根据编译和环境变量加载指定的驱动</h3>\n<div class=\"outline-text-3\" id=\"text-orgc29fcc7\">\n\n<div id=\"org3a917a1\" class=\"figure\">\n<p><img src=\"/2020/02/15/mesa-egl/find_dri.png\"><br>\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-org7dac90e\" class=\"outline-3\">\n<h3 id=\"org7dac90e\">EGL 软件渲染（swrast)驱动加载过程</h3>\n<div class=\"outline-text-3\" id=\"text-org7dac90e\">\n<p>\n因为 DRI 需要保证向后兼容的特性，所以在 dri2, 以及 dri3 中所有的特性都是通过 extension(扩展) 的方式添加的。所以这种情况下，加载完 extension<br>\n后需要使用 extension 的接口来完成操作。所以在调用 <code>loader_open_driver</code> 后返回的是 extension.<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Opens a DRI driver using its driver name, returning the __DRIextension</span></span><br><span class=\"line\"><span class=\"comment\"> * entrypoints.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param driverName - a name like \"i965\", \"radeon\", \"nouveau\", etc.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param out_driver - Address where the dlopen() return value will be stored.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param search_path_vars - NULL-terminated list of env vars that can be used</span></span><br><span class=\"line\"><span class=\"comment\"> * to override the DEFAULT_DRIVER_DIR search path.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">struct</span> __DRIextensionRec **</span><br><span class=\"line\"><span class=\"title function_\">loader_open_driver</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *driver_name,</span></span><br><span class=\"line\"><span class=\"params\">\t\t   <span class=\"type\">void</span> **out_driver_handle,</span></span><br><span class=\"line\"><span class=\"params\">\t\t   <span class=\"type\">const</span> <span class=\"type\">char</span> **search_path_vars)</span></span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\nswrast 初始化过程的函数调用图如下所示<br>\n</p>\n\n\n<div id=\"orgf47f3cc\" class=\"figure\">\n<p><img src=\"/2020/02/15/mesa-egl/loader_open_driver.png\"><br>\n</p>\n</div>\n\n<p>\n对于每一个需要使用 <code>loader_open_driver</code> 加载的，名字为 <code>driver_name</code> 的驱动都会有一个接口 — __driDriverGetExtensions_${driver_name}。通过 dlsym 加载 so 中<br>\n对应的符号，并且执行当前符号对应的函数。从而获取到 <code>driver_name</code> 对应驱动所支持的 extension. 一个 driver 可能有多个 extension。 比如 swrast driver 的 extensions 定义如下。<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">DriverAPIRec</span> <span class=\"title\">galliumsw_driver_api</span> =</span> {</span><br><span class=\"line\">   .InitScreen = drisw_init_screen,</span><br><span class=\"line\">   .DestroyScreen = dri_destroy_screen,</span><br><span class=\"line\">   .CreateContext = dri_create_context,</span><br><span class=\"line\">   .DestroyContext = dri_destroy_context,</span><br><span class=\"line\">   .CreateBuffer = drisw_create_buffer,</span><br><span class=\"line\">   .DestroyBuffer = dri_destroy_buffer,</span><br><span class=\"line\">   .SwapBuffers = drisw_swap_buffers,</span><br><span class=\"line\">   .MakeCurrent = dri_make_current,</span><br><span class=\"line\">   .UnbindContext = dri_unbind_context,</span><br><span class=\"line\">   .CopySubBuffer = drisw_copy_sub_buffer,</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __DRI_SWRAST <span class=\"string\">\"DRI_SWRast\"</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> __DRIswrastExtension driSWRastExtension = {</span><br><span class=\"line\">    .base = { __DRI_SWRAST, <span class=\"number\">4</span> },</span><br><span class=\"line\"></span><br><span class=\"line\">    .createNewScreen            = driSWRastCreateNewScreen,</span><br><span class=\"line\">    .createNewDrawable          = driCreateNewDrawable,</span><br><span class=\"line\">    .createNewContextForAPI     = driCreateNewContextForAPI,</span><br><span class=\"line\">    .createContextAttribs       = driCreateContextAttribs,</span><br><span class=\"line\">    .createNewScreen2           = driSWRastCreateNewScreen2,</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* This is the table of extensions that the loader will dlsym() for. */</span></span><br><span class=\"line\"><span class=\"type\">const</span> __DRIextension *galliumsw_driver_extensions[] = {</span><br><span class=\"line\">    &amp;driCoreExtension.base,</span><br><span class=\"line\">    &amp;driSWRastExtension.base,</span><br><span class=\"line\">    &amp;driCopySubBufferExtension.base,</span><br><span class=\"line\">    &amp;gallium_config_options.base,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> __DRIextension **__driDriverGetExtensions_swrast(<span class=\"type\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">PUBLIC <span class=\"type\">const</span> __DRIextension **__driDriverGetExtensions_swrast(<span class=\"type\">void</span>)</span><br><span class=\"line\">{</span><br><span class=\"line\">   globalDriverAPI = &amp;galliumsw_driver_api;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> galliumsw_driver_extensions;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\neglInitialize 初始化的过程都是基于 EGLDriver 和 EGLDisplay. 很多的配置都在 _EGLDisplay 中， 但是在 egl 的具体驱动中，用到的数据结构大部分是 dri2_egl_xxx, 所以通过如下的宏定义，可以完成数据之间的转换。其中<br>\n</p>\n\n<p>\n通过如下的代码定定义了 dri2_egl 的配置<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Define an inline driver typecast function.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this macro defines a function and should not be ended with a</span></span><br><span class=\"line\"><span class=\"comment\"> * semicolon when used.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _EGL_DRIVER_TYPECAST(drvtype, egltype, code)           \\</span></span><br><span class=\"line\"><span class=\"meta\">   static inline struct drvtype *drvtype(const egltype *obj)   \\</span></span><br><span class=\"line\"><span class=\"meta\">   { return (struct drvtype *) code; }</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Define the driver typecast functions for _EGLDriver, _EGLDisplay,</span></span><br><span class=\"line\"><span class=\"comment\"> * _EGLContext, _EGLSurface, and _EGLConfig.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that this macro defines several functions and should not be ended with</span></span><br><span class=\"line\"><span class=\"comment\"> * a semicolon when used.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _EGL_DRIVER_STANDARD_TYPECASTS(drvname)                            \\</span></span><br><span class=\"line\"><span class=\"meta\">   _EGL_DRIVER_TYPECAST(drvname ## _driver, _EGLDriver, obj)               \\</span></span><br><span class=\"line\"><span class=\"meta\">   <span class=\"comment\">/* note that this is not a direct cast */</span>                               \\</span></span><br><span class=\"line\"><span class=\"meta\">   _EGL_DRIVER_TYPECAST(drvname ## _display, _EGLDisplay, obj-&gt;DriverData) \\</span></span><br><span class=\"line\"><span class=\"meta\">   _EGL_DRIVER_TYPECAST(drvname ## _context, _EGLContext, obj)             \\</span></span><br><span class=\"line\"><span class=\"meta\">   _EGL_DRIVER_TYPECAST(drvname ## _surface, _EGLSurface, obj)             \\</span></span><br><span class=\"line\"><span class=\"meta\">   _EGL_DRIVER_TYPECAST(drvname ## _config, _EGLConfig, obj)</span></span><br><span class=\"line\"></span><br><span class=\"line\">_EGL_DRIVER_STANDARD_TYPECASTS(dri2_egl)</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n_EGL_DRIVER_STANDARD_TYPECASTS 宏最终会扩展处如下几个函数。从第二个函数的代码可以看出，dri2_egl_display 相关的信息全部保存在 _EGLDisplay 的 DriverData(void*) 中<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> dri2_egl_driver* <span class=\"title function_\">dri2_egl_driver</span><span class=\"params\">(_EGLDriver * obj)</span> {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">struct</span> dri2_egl_driver*) obj;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> dri2_egl_display* <span class=\"title function_\">dri2_egl_display</span><span class=\"params\">(_EGLDisplay * obj)</span> {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">struct</span> dri2_egl_display*) obj -&gt; DriverData;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> dri2_egl_context* <span class=\"title function_\">dri2_egl_context</span><span class=\"params\">(_EGLContext * obj)</span> {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">struct</span> dri2_egl_context*) obj;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> dri2_egl_surface* <span class=\"title function_\">dri2_egl_surface</span><span class=\"params\">(_EGLSurface * obj)</span> {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">struct</span> dri2_egl_surface*) obj;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> dri2_egl_config* <span class=\"title function_\">dri2_egl_config</span><span class=\"params\">(_EGLConfig * obj)</span> {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">struct</span> dri2_egl_config*) obj;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n其中 dri2_egl_display 的结构如下所示：<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dri2_egl_display</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dri2_egl_display_vtbl</span> *<span class=\"title\">vtbl</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span>                       dri2_major;</span><br><span class=\"line\">  <span class=\"type\">int</span>                       dri2_minor;</span><br><span class=\"line\">  __DRIscreen              *dri_screen;</span><br><span class=\"line\">  <span class=\"type\">bool</span>                      own_dri_screen;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIconfig       **driver_configs;</span><br><span class=\"line\">  <span class=\"type\">void</span>                     *driver;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIcoreExtension       *core;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIimageDriverExtension *image_driver;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIdri2Extension       *dri2;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIswrastExtension     *swrast;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2flushExtension     *flush;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2flushControlExtension *flush_control;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRItexBufferExtension  *tex_buffer;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIimageExtension      *image;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIrobustnessExtension *robustness;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRInoErrorExtension    *no_error;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2configQueryExtension *config;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2fenceExtension *fence;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2bufferDamageExtension *buffer_damage;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2blobExtension *blob;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2rendererQueryExtension *rendererQuery;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRI2interopExtension *interop;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIconfigOptionsExtension *configOptions;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRImutableRenderBufferDriverExtension *mutable_render_buffer;</span><br><span class=\"line\">  <span class=\"type\">int</span>                       fd;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* dri2_initialize/dri2_terminate increment/decrement this count, so does</span></span><br><span class=\"line\"><span class=\"comment\">   * dri2_make_current (tracks if there are active contexts/surfaces). */</span></span><br><span class=\"line\">  <span class=\"type\">int</span>                       ref_count;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">bool</span>                      own_device;</span><br><span class=\"line\">  <span class=\"type\">bool</span>                      invalidate_available;</span><br><span class=\"line\">  <span class=\"type\">int</span>                       min_swap_interval;</span><br><span class=\"line\">  <span class=\"type\">int</span>                       max_swap_interval;</span><br><span class=\"line\">  <span class=\"type\">int</span>                       default_swap_interval;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> HAVE_DRM_PLATFORM</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gbm_dri_device</span>    *<span class=\"title\">gbm_dri</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span>                     *driver_name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIextension    **loader_extensions;</span><br><span class=\"line\">  <span class=\"type\">const</span> __DRIextension    **driver_extensions;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> HAVE_X11_PLATFORM</span></span><br><span class=\"line\">  <span class=\"type\">xcb_connection_t</span>         *conn;</span><br><span class=\"line\">  <span class=\"type\">xcb_screen_t</span>             *screen;</span><br><span class=\"line\">  <span class=\"type\">bool</span>                     swap_available;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> HAVE_DRI3</span></span><br><span class=\"line\">  <span class=\"type\">bool</span>                     multibuffers_available;</span><br><span class=\"line\">  <span class=\"type\">int</span>                      dri3_major_version;</span><br><span class=\"line\">  <span class=\"type\">int</span>                      dri3_minor_version;</span><br><span class=\"line\">  <span class=\"type\">int</span>                      present_major_version;</span><br><span class=\"line\">  <span class=\"type\">int</span>                      present_minor_version;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">loader_dri3_extensions</span> <span class=\"title\">loader_dri3_ext</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> HAVE_WAYLAND_PLATFORM</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wl_display</span>        *<span class=\"title\">wl_dpy</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wl_display</span>        *<span class=\"title\">wl_dpy_wrapper</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wl_registry</span>       *<span class=\"title\">wl_registry</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wl_drm</span>            *<span class=\"title\">wl_server_drm</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wl_drm</span>            *<span class=\"title\">wl_drm</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wl_shm</span>            *<span class=\"title\">wl_shm</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wl_event_queue</span>    *<span class=\"title\">wl_queue</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zwp_linux_dmabuf_v1</span> *<span class=\"title\">wl_dmabuf</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">u_vector</span>          *<span class=\"title\">wl_modifiers</span>;</span></span><br><span class=\"line\">  <span class=\"type\">bool</span>                      authenticated;</span><br><span class=\"line\">  BITSET_DECLARE(formats, EGL_DRI2_MAX_FORMATS);</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span>                  capabilities;</span><br><span class=\"line\">  <span class=\"type\">char</span>                     *device_name;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> HAVE_ANDROID_PLATFORM</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">gralloc_module_t</span> *gralloc;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">bool</span>                      is_render_node;</span><br><span class=\"line\">  <span class=\"type\">bool</span>                      is_different_gpu;</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n一个 dri2_egl_display 可以通过不同的 extension 进行显示, 所以这种情况下需要将需要的 extension 绑定到 dri2_egl_display 上。通过如下的函数将<br>\nmatches 中要求的指定的 extension, 从 extensions 参数中绑定到 dri2_egl_display 中（EGLDisplay-&gt;DriverData）<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> EGLBoolean</span><br><span class=\"line\"><span class=\"title function_\">dri2_bind_extensions</span><span class=\"params\">(<span class=\"keyword\">struct</span> dri2_egl_display *dri2_dpy,</span></span><br><span class=\"line\"><span class=\"params\">\t\t     <span class=\"type\">const</span> <span class=\"keyword\">struct</span> dri2_extension_match *matches,</span></span><br><span class=\"line\"><span class=\"params\">\t\t     <span class=\"type\">const</span> __DRIextension **extensions,</span></span><br><span class=\"line\"><span class=\"params\">\t\t     <span class=\"type\">bool</span> optional)</span></span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n在 swrast 驱动中，通过 dri2_bind_extensions 将 dri2_egl_display 中的 swrast, core 之类的绑定为 __DRIextension. <code>__DRIextension</code> 是所有 extension 的基类。<br>\n比如 <code>__DRIswrastExtension</code> 的定义如下<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">DRIswrastExtensionRec</span> {</span></span><br><span class=\"line\">  __DRIextension base;</span><br><span class=\"line\"></span><br><span class=\"line\">  __DRIscreen *(*createNewScreen)(<span class=\"type\">int</span> screen,</span><br><span class=\"line\">\t\t\t\t  <span class=\"type\">const</span> __DRIextension **extensions,</span><br><span class=\"line\">\t\t\t\t  <span class=\"type\">const</span> __DRIconfig ***driver_configs,</span><br><span class=\"line\">\t\t\t\t  <span class=\"type\">void</span> *loaderPrivate);</span><br><span class=\"line\"></span><br><span class=\"line\">  __DRIdrawable *(*createNewDrawable)(__DRIscreen *screen,</span><br><span class=\"line\">\t\t\t\t      <span class=\"type\">const</span> __DRIconfig *config,</span><br><span class=\"line\">\t\t\t\t      <span class=\"type\">void</span> *loaderPrivate);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Since version 2 */</span></span><br><span class=\"line\">  __DRIcontext *(*createNewContextForAPI)(__DRIscreen *screen,</span><br><span class=\"line\">\t\t\t\t\t  <span class=\"type\">int</span> api,</span><br><span class=\"line\">\t\t\t\t\t  <span class=\"type\">const</span> __DRIconfig *config,</span><br><span class=\"line\">\t\t\t\t\t  __DRIcontext *shared,</span><br><span class=\"line\">\t\t\t\t\t  <span class=\"type\">void</span> *data);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Create a context for a particular API with a set of attributes</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * \\since version 3</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * \\sa __DRIdri2ExtensionRec::createContextAttribs</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  __DRIcontext *(*createContextAttribs)(__DRIscreen *screen,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">int</span> api,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">const</span> __DRIconfig *config,</span><br><span class=\"line\">\t\t\t\t\t__DRIcontext *shared,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">unsigned</span> num_attribs,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">const</span> <span class=\"type\">uint32_t</span> *attribs,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">unsigned</span> *error,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">void</span> *loaderPrivate);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * createNewScreen() with the driver extensions passed in.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * \\since version 4</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  __DRIscreen *(*createNewScreen2)(<span class=\"type\">int</span> screen,</span><br><span class=\"line\">\t\t\t\t   <span class=\"type\">const</span> __DRIextension **loader_extensions,</span><br><span class=\"line\">\t\t\t\t   <span class=\"type\">const</span> __DRIextension **driver_extensions,</span><br><span class=\"line\">\t\t\t\t   <span class=\"type\">const</span> __DRIconfig ***driver_configs,</span><br><span class=\"line\">\t\t\t\t   <span class=\"type\">void</span> *loaderPrivate);</span><br><span class=\"line\"></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n所以在 dri2_bind_extensions 之后， 对于 dri2_egl_display 中，所有的字段，持有的都是子类的指针，这样就能调用到子类的对应函数中。比如 <code>const __DRIswrastExtension *swrast;</code><br>\n</p>\n\n<p>\n通过 createNewScreen2 调用 pipe_loader_sw_probe_dri 从而能获取到，使用什么样的 <code>pipe_loader_device</code> 进行初始化。 其中 pipe_loader_device 定义如下<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_loader_ops</span> {</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_screen</span> *(*<span class=\"title\">create_screen</span>)(<span class=\"keyword\">struct</span> <span class=\"title\">pipe_loader_device</span> *<span class=\"title\">dev</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t       <span class=\"title\">const</span> <span class=\"keyword\">struct</span> <span class=\"title\">pipe_screen_config</span> *<span class=\"title\">config</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *(*get_driconf_xml)(<span class=\"keyword\">struct</span> pipe_loader_device *dev);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">void</span> (*release)(<span class=\"keyword\">struct</span> pipe_loader_device **dev);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_loader_device</span> {</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">pipe_loader_device_type</span> <span class=\"title\">type</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> {</span></span><br><span class=\"line\">      <span class=\"type\">int</span> vendor_id;</span><br><span class=\"line\">      <span class=\"type\">int</span> chip_id;</span><br><span class=\"line\">    } pci;</span><br><span class=\"line\">  } u; <span class=\"comment\">/**&lt; Discriminated by \\a type */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span> *driver_name;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_loader_ops</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  driOptionCache option_cache;</span><br><span class=\"line\">  driOptionCache option_info;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_loader_sw_device</span> {</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_loader_device</span> <span class=\"title\">base</span>;</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sw_driver_descriptor</span> *<span class=\"title\">dd</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> GALLIUM_STATIC_TARGETS</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">util_dl_library</span> *<span class=\"title\">lib</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sw_winsys</span> *<span class=\"title\">ws</span>;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> fd;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sw_driver_descriptor</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_screen</span> *(*<span class=\"title\">create_screen</span>)(<span class=\"keyword\">struct</span> <span class=\"title\">sw_winsys</span> *<span class=\"title\">ws</span>);</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> {</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sw_winsys</span> *(*<span class=\"title\">create_winsys</span>)();</span></span><br><span class=\"line\">  } winsys[];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n对于软件渲染来讲，pipe_loader 创建屏幕的任务主要会由 <code>pipe_loader_sw_create_screen</code> 来完成。相应的 device 也使用上面所定义的 pipe_loader_sw_device (<code>pipe_loader_device</code> 的子类)来进行初始化。<br>\n在 pipe_loader_sw_create_screen 中相应的将创建 screen 的任务交给 sw_driver_descriptor 中的 create_screen.<br>\n</p>\n\n<p>\nsw_driver_descriptor 通过如下的方式进行初始化<br>\n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sw_driver_descriptor</span> <span class=\"title\">driver_descriptors</span> =</span> {</span><br><span class=\"line\">   .create_screen = sw_screen_create,</span><br><span class=\"line\">   .winsys = {</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> HAVE_PIPE_LOADER_DRI</span></span><br><span class=\"line\">      {</span><br><span class=\"line\">\t .name = <span class=\"string\">\"dri\"</span>,</span><br><span class=\"line\">\t .create_winsys = dri_create_sw_winsys,</span><br><span class=\"line\">      },</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> HAVE_PIPE_LOADER_KMS</span></span><br><span class=\"line\">      {</span><br><span class=\"line\">\t .name = <span class=\"string\">\"kms_dri\"</span>,</span><br><span class=\"line\">\t .create_winsys = kms_dri_create_winsys,</span><br><span class=\"line\">      },</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n对于软件渲染来讲创建过程再次被代理 — sw_screen_create 进行处理。 最终调用 sw_screen_create_named 方法进行 screen 的创建。sw_screen_create_named 实现如下<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> pipe_screen *</span><br><span class=\"line\"><span class=\"title function_\">sw_screen_create_named</span><span class=\"params\">(<span class=\"keyword\">struct</span> sw_winsys *winsys, <span class=\"type\">const</span> <span class=\"type\">char</span> *driver)</span></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_screen</span> *<span class=\"title\">screen</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(GALLIUM_LLVMPIPE)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (screen == <span class=\"literal\">NULL</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(driver, <span class=\"string\">\"llvmpipe\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    screen = llvmpipe_create_screen(winsys);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(GALLIUM_VIRGL)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (screen == <span class=\"literal\">NULL</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(driver, <span class=\"string\">\"virpipe\"</span>) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">virgl_winsys</span> *<span class=\"title\">vws</span>;</span></span><br><span class=\"line\">    vws = virgl_vtest_winsys_wrap(winsys);</span><br><span class=\"line\">    screen = virgl_create_screen(vws, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(GALLIUM_SOFTPIPE)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (screen == <span class=\"literal\">NULL</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(driver, <span class=\"string\">\"softpipe\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    screen = softpipe_create_screen(winsys);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(GALLIUM_SWR)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (screen == <span class=\"literal\">NULL</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(driver, <span class=\"string\">\"swr\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    screen = swr_create_screen(winsys);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> screen;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\n最终会选择到相应的 gallium driver 上进行 screen 的创建工作。<br>\n</p>\n</div>\n</div>\n<div id=\"outline-container-orgb4b72c4\" class=\"outline-3\">\n<h3 id=\"orgb4b72c4\">Gallium 加载过程</h3>\n<div class=\"outline-text-3\" id=\"text-orgb4b72c4\">\n\n<div id=\"org689af22\" class=\"figure\">\n<p><img src=\"/2020/02/15/mesa-egl/gallium_deq.png\"><br>\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-org022cef4\" class=\"outline-3\">\n<h3 id=\"org022cef4\">egl 函数调用分析</h3>\n<div class=\"outline-text-3\" id=\"text-org022cef4\">\n<p>\negl 规范，由一些列的接口定义组成。在 mesa 的 egl 的实现中，egl 规范相关的定义在 _EGLDriver 结构体中。结构体的部分实际结构如下所示：<br>\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The API dispatcher jumps through these functions</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">egl_api</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">  <span class=\"comment\">/* driver funcs */</span></span><br><span class=\"line\">  EGLBoolean (*Initialize)(_EGLDriver *, _EGLDisplay *disp);</span><br><span class=\"line\">  EGLBoolean (*Terminate)(_EGLDriver *, _EGLDisplay *disp);</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *(*QueryDriverName)(_EGLDisplay *disp);</span><br><span class=\"line\">  <span class=\"type\">char</span> *(*QueryDriverConfig)(_EGLDisplay *disp);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* context funcs */</span></span><br><span class=\"line\">  _EGLContext *(*CreateContext)(_EGLDriver *drv, _EGLDisplay *disp,</span><br><span class=\"line\">\t\t\t\t_EGLConfig *config, _EGLContext *share_list,</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">const</span> EGLint *attrib_list);</span><br><span class=\"line\">  EGLBoolean (*DestroyContext)(_EGLDriver *drv, _EGLDisplay *disp,</span><br><span class=\"line\">\t\t\t       _EGLContext *ctx);</span><br><span class=\"line\">  <span class=\"comment\">/* this is the only function (other than Initialize) that may be called</span></span><br><span class=\"line\"><span class=\"comment\">   * with an uninitialized display</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  EGLBoolean (*MakeCurrent)(_EGLDriver *drv, _EGLDisplay *disp,</span><br><span class=\"line\">\t\t\t    _EGLSurface *draw, _EGLSurface *read,</span><br><span class=\"line\">\t\t\t    _EGLContext *ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* surface funcs */</span></span><br><span class=\"line\">  _EGLSurface *(*CreateWindowSurface)(_EGLDriver *drv, _EGLDisplay *disp,</span><br><span class=\"line\">\t\t\t\t      _EGLConfig *config, <span class=\"type\">void</span> *native_window,</span><br><span class=\"line\">\t\t\t\t      <span class=\"type\">const</span> EGLint *attrib_list);</span><br><span class=\"line\">  _EGLSurface *(*CreatePixmapSurface)(_EGLDriver *drv, _EGLDisplay *disp,</span><br><span class=\"line\">\t\t\t\t      _EGLConfig *config, <span class=\"type\">void</span> *native_pixmap,</span><br><span class=\"line\">\t\t\t\t      <span class=\"type\">const</span> EGLint *attrib_list);</span><br><span class=\"line\">  _EGLSurface *(*CreatePbufferSurface)(_EGLDriver *drv, _EGLDisplay *disp,</span><br><span class=\"line\">\t\t\t\t       _EGLConfig *config,</span><br><span class=\"line\">\t\t\t\t       <span class=\"type\">const</span> EGLint *attrib_list);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</div>\n\n<p>\nmesa 中 egl 的实现有两种， 依据 dri 实现的 src/egl/drivers/egl_dri2.cpp, 和 基于 haiku 实现的 src/egl/drivers/haiku/egl_haiku.cpp<br>\n</p>\n</div>\n<div id=\"outline-container-org9959ed0\" class=\"outline-4\">\n<h4 id=\"org9959ed0\">eglInitialize 的调用链</h4>\n<div class=\"outline-text-4\" id=\"text-org9959ed0\">\n\n<div id=\"org8424378\" class=\"figure\">\n<p><img src=\"/2020/02/15/mesa-egl/mesa-draw.png\"><br>\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-orgc81c3f4\" class=\"outline-4\">\n<h4 id=\"orgc81c3f4\">egl_dri2 eglCreateContext 调用链</h4>\n<div class=\"outline-text-4\" id=\"text-orgc81c3f4\">\n\n<div id=\"orgd935224\" class=\"figure\">\n<p><img src=\"/2020/02/15/mesa-egl/mesa-eglCreateContext.png\"><br>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</body></html>","prev":{"title":"用 orgmode 在 hexo 上写博客","link":"2020/03/05/hexo"},"next":{"title":"Mesa3D 编译","link":"2020/02/15/mesa"},"plink":"https://kopinions.com/2020/02/15/mesa-egl/","toc":[{"id":"orgf777b56","title":"mesa 架构详解","index":"1","children":[{"id":"orga1964c7","title":"mesa 架构","index":"1.1"},{"id":"orgc29fcc7","title":"EGL 根据编译和环境变量加载指定的驱动","index":"1.2"},{"id":"org7dac90e","title":"EGL 软件渲染（swrast)驱动加载过程","index":"1.3"},{"id":"orgb4b72c4","title":"Gallium 加载过程","index":"1.4"},{"id":"org022cef4","title":"egl 函数调用分析","index":"1.5"}]}],"reading_time":"1814 字约 12 分钟"}