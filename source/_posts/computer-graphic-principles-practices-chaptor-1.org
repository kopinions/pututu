#+TITLE:  计算机图形学原理及实践学习笔记
#+AUTHOR: 孙建康（rising.lambda）
#+EMAIL:  rising.lambda@gmail.com
#+DATE: <2019-11-09 10:40:20>
#+UPDATED: <2019-11-09>
#+LAYOUT: post
#+EXCERPT: 对解决方案进行近似处理，而不是对问题进行近似处理。确定自己工作在什么问题上，并且能清晰的描述问题。而不是对问题有个大概的认识。 这样很多时候有可能你永远也找不到解决方案因为你不正确的问题上。或者直接对问题进行近似，这样有可能得出的解决方案也是错的。
#+DESCRIPTION: 对解决方案进行近似处理，而不是对问题进行近似处理。确定自己工作在什么问题上，并且能清晰的描述问题。而不是对问题有个大概的认识。 这样很多时候有可能你永远也找不到解决方案因为你不正确的问题上。或者直接对问题进行近似，这样有可能得出的解决方案也是错的。
#+TAGS: OpenGL, Graphics
#+CATEGORIES: Graphics,OpenGL
#+PROPERTY:    header-args        :comments org
#+PROPERTY:    header-args        :mkdirp yes
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil \n:t
#+OPTIONS:     tex:magick
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+BIND: org-preview-latex-image-directory "./computer-graphic-principles-practices-chaptor-1"
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

** 计算机图形学原理及实践

*** 基本概念

| 概念                            | 中文     | 含义                                                         | 用途 |
|---------------------------------+----------+--------------------------------------------------------------+------|
| model                           |          |                                                              |      |
| modeling                        |          |                                                              |      |
| visual perception               |          |                                                              |      |
| visual commutation              |          |                                                              |      |
| rendering                       |          | 将一些列的物体显示出来的过程                                 |      |
| dynamic range <<dynamic_range>> | 动态范围 | 可变信号（光，声音）最大值和最小值的比值                     |      |
| resolution                      | 分辨率   | 两个物体刚好能分辨开的距离                                   |      |
|---------------------------------+----------+--------------------------------------------------------------+------|
| sampling                        | 采样     | 摄像机和人眼的观察原理类似，曝光一段时间                     |      |
|                                 |          | 积累光子能量，从而得到相关点上的各种属性                     |      |
|                                 |          | 因为性能和成本考虑采样不可能在每个顶点上发                   |      |
|                                 |          | 采集光子能量，所以需要只在部分顶点上采集相关信息，称之为采样 |      |
|---------------------------------+----------+--------------------------------------------------------------+------|

*** 原则

1. 知道自己在解决什么样的问题
2. 对解决方案进行近似处理，而不是对问题进行近似处理。确定自己工作在什么问题上，并且能清晰的描述问题。而不是对问题有个大概的认识。
   这样很多时候有可能你永远也找不到解决方案因为你不正确的问题上。或者直接对问题进行近似，这样有可能得出的解决方案也是错的。
3. 对于任何工程项目来讲，都有自己的预算（时间，成本，大小）等等。需要我们做好取舍
4. 使用自己最方便的坐标系，然后通过转换到不同的坐标系上

*** 一些数值

#+CAPTION: 一些数值
#+ATTR_HTML: border="2" rules="all" frame="border"
#+ATTR_LATEX: :mode math-inline
| 数值                                  | 表达式                                                                     | 量级  | 单位       | 范围         | 说明                                                                   | 用途 |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 可见光波长                            |                                                                            | 10^{-9}  | m          | 400-700nm    | 可见光的范围                                                           |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 发丝的直径                            |                                                                            | 10^{-4}  | m          |              | 是可见光的波长的100-200倍                                              |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 光子的能量                            | E=hc/\lambda                                                                     |       |            |              | h \approx 6.6 \times 10^{-34} Js 是普朗克常数,单位是焦耳秒                           |      |
|                                       | $$ E\approx\frac{1.98 \times 10 ^{-25} Jm}{\lambda} $$                                      |       |            |              | c \approx 3 \times 10^{8} 光速                                                       |      |
|                                       |                                                                            |       |            |              | E 是光子所拥有的能量                                                   |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 灯泡的瓦数                            |                                                                            | 10^{1-2} | W 或者 J/s | 10-100W      | W 是 J / S, J 是 焦耳                                                  |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 灯泡的能量可以转换成光子数            | $$ photons = \frac{2 J/s}{E} $$                                            | 10^{18}  | 个/s       |              | E 可以根据灯泡发光的波长算出来，一个光子的能量，                       |      |
|                                       |                                                                            |       |            |              | 通过这个方程可以将能量转换为光子数量                                   |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 单位平面的光子数                      | $$ p = \frac{photons}{flux} $$                                             |       | 个/m^{2}/s    |              |                                                                        |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 常见显示器像素数                      |                                                                            | 10^{6}   | 个         |              |                                                                        |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 常见显示器[[dynamic_range][动态范围]] |                                                                            | 10^{2}   | 500:1      |              | 最亮的点发送光子的数量和最暗的点发送光子数量的比值                     |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 人眼的角分辨率                        |                                                                            |       | 弧度       | 1角分－3角分 | 人眼分辨率一般用角分辨率来定义.可以转换为1 km 能分辨两个点而不是一个点 |      |
|                                       |                                                                            |       |            |              | 要求这两个点最小离开的距离 0.3m / 1km                                  |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|
| 数字相机单位传感器光子数              | $$ \frac{sensor count}{photon generate by light source in unit of time} $$ |       | 个         |              | 单位时间到传感器的光子是有限的，所以我们需要调整快门速度，来调整曝光   |      |
|---------------------------------------+----------------------------------------------------------------------------+-------+------------+--------------+------------------------------------------------------------------------+------|

*** 人眼的一些特性

1. 中央区域分辨率高，人视线焦点处
2. 边缘处分辨率较低
3. 对移动非常敏感（比如屏幕闪烁）
4. 对水平或者垂直的变化比较敏感，对对角线上的变换不敏感
5. 对明暗的感知不是线性的
6. 对轮廓比较敏感


** 2D Graphics

对于 2D 的图形应用来讲，我们将业务模型（Application Model）通过一定的手段进行建模，以图形化的形式显示出来，同事可以与用户进行交互，从而完成实际的业务功能。比如设计领域，建模领域之类的一些软件。

*** 图形系统演进史

图形系统的演进和很多很多编程语言，编程平台（操作系统）的演进是类似的。每一个新的迭代都会提供更高的抽象，以及将以前很多必须由应用程序完成的工作，放在图形系统中完成。我们接下来会看下整个图形系统的演进过程

**** 整型坐标系统到浮点坐标系统
在80年代以及90年代早期，一些图形系统可以支持在矩形画布（Canvas）上进行绘制。在画布上绘制的时候，并不是直接绘制单独的像素，而是绘制图元（primitives）。这里的图元指的是：几何形状（多边形，圆形），或者提前加载好的
矩形形状的图片。图元定义了轮廓信息。通过一些属性来控制图元实际的展示效果，比如 brush 控制图元内部应该如何显示，比如 solid-gray 填充。比如 pen 控制图元的轮廓如何显示， 比如 red-pen.

当时应用程序的典型处理场景是：在 Canvas 以整型坐标系进行绘制，并将绘制结果按照一一对应的方式映射到屏幕上。Canvas 上最左上角为整型坐标系的原点，向右为X 轴正向，向下为 Y 轴的正方向。

***** 不同屏幕显示的不一样大小
在我们讲解这个问题之前先来看下屏幕的相关知识。

在屏幕技术指标中有一个指标叫屏幕分辨率。这个指标主要用来衡量显示器对细节的分辨能力。分辨率越高意味着展示的信息更多，细节更多。对于数字设备来讲分辨率的单位是 PPI(Pixel Per Inch), 每 Inch 可以显示的像素数量。

因为整型坐标系的原因，canvas 和 屏幕是1对1 映射。如果屏幕分辨率高（单位尺寸拥有的像素点多 ppi 比较大）那么最终显示尺寸就会很小。如果屏幕的分辨率低（单位尺寸拥有的像素点少），那么最终显示的图元就会非常大。

比如我们设计的尺寸为 100 * 100 个点的正方形。在 300 ppi 的显示器上最终的成像尺寸是 100 / 300 = 0.33 inch (英尺). 在 72 ppi 的屏幕上追中成像尺寸是： 100 / 72 = 1.38 inch

最终成像的大小相差非常巨大。为了解决这种屏幕分辨率依赖的问题，引入了在矢量图形中非常成熟的技术：通过浮点数来映射坐标系统，来隔离设备相关的特性。

****** 抽象坐标系
假设我们在纸上对一个钟表建模，我们首先在纸上画一个二维座标系，将钟表的中心放置在座标系的中间，然后分别在座标系原点绘制三个指针。我们用纸上的这个坐标系来对钟表建模，但是建模出来的坐标，不一定就是
实际我们看到的坐标，比如我们需要把纸挪动一下以便与观察。我们将纸上的这个坐标系称之为抽象坐标系，它不表示世界的物理世界的位置，或者尺寸。在我们最终要展示到现实世界的时候，我们需要对抽象坐标系进行
一次映射，将其映射为现实世界中的物理坐标系。

当使用抽象坐标系去描述场景的时候，我们需要去考虑如下几个因素：
1. 显示设备的特性：尺寸，分辨率，纵横比
2. 在上面设备特性的约束下，我们希望我们最终成像的尺寸和位置
3. 如何定义集合结构，以便满足预期的结果

****** 物理坐标系
在 1980 年的时候，Mac 和 Windows 一起定义了一个独立与硬件的尺寸单位 DIU (Device Indenpent Unit), 这个 DIU 尺寸是 $$ \frac{1}{72} $$ inch.
假设我们定义我们表盘的直径是 1 inch.
当我们决定将抽象坐标系的钟表图像现实到物理坐标系的时候，如果只是一一映射，这种时候会出现如下几个问题：
1. 设备的坐标系都是最左上点的坐标为 0,0, 所以这种情况下， 钟表指能显示出来最右下角的 1/4.
2. 抽象坐标系定义的是相对的 size，比如可能只有 -1到1来 表示 1 inch，当转换到 96 PPI 的显示器上的时候，只有 0.02 inch(2/96 \approx 0.02), 会非常小。

所以在展示到物理坐标系的时候，我们需要进行转换。

1. 缩放，将 2 ppi 的表盘的坐标映射到， 96 ppi 的坐标，意味着我们需要对于表盘上的每个坐标 $$ x = x \times \frac{96}{2} $$
2. 平移

对于变换是有顺序的。对于上面的粒子比如如果先将表盘原点移动到 1, 1，然后在进行缩放，这样会导致部分的表盘还是无法展示。

**** 即时模式（Immedicate Mode） vs 保留模式 (Retained Mode)
随着图形系统的演进，出现了两种截然不同的需求，进而催生出两个不同的图形系统的处理方向和模式：
1. 对性能非常敏感，或者在受限的硬件下的这部分场景，仅仅需要图形系统提供一套高效的硬件操作接口，其他的图形相关的事情由应用开发着去自行的实现。我们称这种模式为即时模式
2. 对开发效率非常敏感，希望图形系统尽量把公共的事情处理完，应用开发者只需要关心实际的场景的操作编写就可以。我们称这种模式为保留模式。

在即时模式下，图形系统仅仅是应用程序和硬件之间非常薄的一层接口。这层接口不同保存任何应用程序定义的图元信息，而是在应用程序调用的时候（比如画矩形），图形系统直接执行相关的操作－－ 将矩形的坐标
映射到设备坐标系并且将对应的像素写入到显示缓冲区，然后将控制权直接返回给应用程序。这种时候如果需要对渲染好的图像进行处理，需要应用程序去遍历所有的业务模型，来重新生成图元，来重新进行渲染过程。
同时应用程序开发者还需要需要处理一些常见的处理逻辑，比如鼠标处理，目标拾取（用户点击的时候，是对哪一个物体进行操作），等等。
在即时模式下，应用程序开发者对整个软件有更大的可控性，同时意味着对应用程序开发者有更高的要求。


在保留模式下，将所有场景中出现的图元保存进一个特殊的数据库，场景图数据库（scene graph）。应用程序开发者通过调用图形系统提供的 API, 来创建 scene graph, 并且可以通过增量修改的方式来修改 scene graph.
任何变更都会导致场景图同步器触发相应的处理，应用相应的变更，并且渲染到屏幕上。因为所有的图元和状态都被保存在图形系统中，所以图形系统可以做很多通用的任务，比如目标拾取，鼠标处理。

在 60 年代有一个非常有远见的软件 Sketchpad. 这个软件开启了交互软件这一个新的领域。在这个软件中由如下几个概念：

1. master template: 一组图元以及下一级 template 的 instance 的集合
2. instance: 一个 template 通过实例化创建的 instance. instance 可以被用来组成渲染的场景。每一个 instance 可以被进行各种几何操作：平移，旋转，缩放。有一个需要注意的是，instance 保留的是 master 的值，
所以如果 master 发生变更，所有的改动会立即反映到所有的 instance 上。

Sketchpad 的这个概念在很多现在的图形系统中依然存在。很多时候可能会以不同的命名存在，比如 UI Controls, Widgets. 

现在 2D 图形系统基本上都是保留模式，但是 3D 系统相对就没有这么普遍，因为 3D 模式下比较复杂，保留模式的成本相对比较高。

**** 过程式（Procedural） vs 声明式（Declarative）

***** 过程式：通过编写代码，顺序的调用图形系统的API 来和设备交互最终通过这种形式来完成实际的业务功能。－－－描述如何去做（把大象装进冰箱1. 打开冰箱门，2:把大象装进去， 3: 关闭冰箱门）

***** 声明式：通过描述想做的事情，具体这件事情如何去做，有专门的工具去做相应的处理。－－－ 描述做什么（把大象装进冰箱，具体怎么装，由其他工具处理）

*** 现实图形管线隐喻
    [[./computer-graphic-principles-practices-chaptor-1/ancient_renderer.jpg]]
**** 几个名词
     1. String 长线（光线）
     2. Screw eye小图钉（观察者/照相机/观察点）
     3. Pointer 指向器/取样器（用来指向物体中的某一部分）
     4. Shutter 百叶窗(视窗)
     5. Pencil-mark 铅笔（画图）
 
**** 渲染过程

传统画图算法的伪代码
#+BEGIN_SRC text :exports code :eval never
Input: a scene containing some objects, location of eye-point 
Output: a drawing of the objects

initialize drawing to be blank foreach object o
for visible point P of o 
    Open shutter
    Place pointer at P
    if string from P to eye-point touches boundary of frame 
        Do nothing
    else
        Hold a pencil at point where string passes through frame Hold string aside
	Close shutter to make pencil-mark on paper
	Release string
    fi
end
#+END_SRC

在这个算法中由三点需要注意
1. 只需要画可以看见的点
2. 取样点是由有限的
3. 当取样点和观察点的线和百叶窗边框相交的时候忽略当前取样点

如果把这个古老的渲染引擎使用数学办法进行建模的话，我们可以得到如下的数学模型

[[./computer-graphic-principles-practices-chaptor-1/antient_renderer_derivation.jpg]]

三个坐标轴是右手坐标系的坐标轴。 z 轴指向物体（百叶窗），y 轴指向上方，x 轴指向左侧（在观察点位置）这里百叶窗处在 z = 1 的平面，意味着 对于百业窗相交点，任何一个点 (x, y, z) 的位置可以表示为 (x', y', 1).
红色三角形中，（0, y, z) 的点， 与百叶窗的交点是 (0, y', 1), 通过将 (0, y', 1) 投影到 z=0 平面，我们会获得 (0, y', 0)
将 (0, y, z). 投影到 z=0 平面，我们会获得 (0, y, 0) 的点，因为两个三角形的内角一样，所以 $$ \frac{y'}{1(z = 1)} = \frac{y}{z} $$ 
对于 x 轴上的所有点，使用类似的计算方法，我们就可以得到，百叶窗上相交的所有点的坐标

$$ x' = \frac{x}{z} $$ 
$$ y' = \frac{y}{z} $$ 


所以此时我们的伪代码就可以变成如下的数学描述方式

#+BEGIN_SRC text :exports code :eval never
Input: a scene containing some objects
Output: a drawing of the objects
initialize drawing to be blank foreach object o

foreach visible point P = (x, y, z) of o

if xmin ≤ (x/z) ≤ xmax and ymin ≤ (y/z) ≤ ymax
    make a point on the drawing at location (x/z, y/z)
#+END_SRC

有一个小细节，在这个坐标系中，当 x 轴增加的时候，我们在观察点处看到的是向左边增加的，就意味者我们需要从右往左边画，跟常见的/通用的建模手段不匹配，所以我们在这里做一个小小的变换 (x/z -> -x/z)
#+BEGIN_SRC text :exports code :eval never
if xmin ≤ (x/z) ≤ xmax and ymin ≤ (y/z) ≤ ymax
    make a point on the drawing at location (-x/z, y/z)
#+END_SRC

假设我们现在需要用刚才的数学模型来绘制一个立方体的线框图，最直观的立方体的描述就是 8 个三维中的点

#+BEGIN_SRC text :exports code :eval never
(−0.5, −0.5, -0.5)
(-0.5, 0.5, −0.5)
(0.5, 0.5, -0.5)
(0.5, -0.5, -0.5)
(-0.5, -0.5, 0.5)
(-0.5, 0.5, 0.5)
(0.5, 0.5, 0.5)
(0.5, -0.5, 0.5)
#+END_SRC

这也就是我们所谓的模型坐标系，但是这种情况下，我们的立方体是看不见的，这个立方体在百叶窗的后面 (z < 1)

所以我们需要对这个模型进行对应的平移，将模型移动到百叶窗的的前面 (z > 1). 这一步即现在渲染系统中的模型转换矩阵所做的事情

#+BEGIN_SRC text :exports code :eval never
(−0.5, −0.5, 2.5)
(-0.5, 0.5, 2.5)
(0.5, 0.5, 2.5)
(0.5, -0.5, 2.5)
(-0.5, -0.5, 3.5)
(-0.5, 0.5, 3.5)
(0.5, 0.5, 3.5)
(0.5, -0.5, 3.5)
#+END_SRC


*** 人眼系统

**** 特性
1. 对物体的感知与光照环境无关。
2. 对形状轮廓（检测边， 不同亮度区域的边界）非常敏感
3. 可以不同形状轮廓进行拼接以便与进一步识别处理（色盲测试卡）
4. 人眼在检测深度的时候会由两种机制：聚焦机制（人眼焦点判断物体远近），视差机制（两个眼睛有一定的距离，成像必然会在水平方向有一定的差异，这种差异可以被用来识别物体的远景。当物体超过1300m 的时候，视差为0, 所以我们
   没有办法判断特别远的物体的深度）。
5. 不变性，不会随着光线，颜色，形状，大小的变化而对最终识别的结果产生影响（白天 vs 晚上因为光线的原因，人眼看到的颜色是不一样的； 不同方向看到的形状是不一样的； 不同距离看到的大小不一样，这些情况下人眼
   都能够很好的识别同一个物体）。 不变性带来的一个非常重要的图形学的影响就是：对于一些值来讲，相对指比绝对值更加重要。
